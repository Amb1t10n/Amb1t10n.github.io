{"meta":{"title":"amb1t10n's blog","subtitle":"","description":"","author":"amb1t10n","url":"http://amb1t10n.github.io","root":"/"},"pages":[{"title":"关于自己","date":"2020-01-15T03:08:28.000Z","updated":"2020-01-15T03:47:03.582Z","comments":true,"path":"about/index.html","permalink":"http://amb1t10n.github.io/about/index.html","excerpt":"","text":"谈谈写博客的想法 作为一个以后要靠技术吃饭的 清(you)纯(ni)少(da)年(shu) 有一个自己的blog是有必要的 而且在成长的过程中 对身边的一些事情有一些看法 自己也不想去发到QQ空间这种地方让公开评论 就想着发到blog中 算是发泄一下自己的小情绪吧"},{"title":"Categories","date":"2020-03-01T11:16:25.000Z","updated":"2020-03-01T11:17:02.398Z","comments":true,"path":"category/index.html","permalink":"http://amb1t10n.github.io/category/index.html","excerpt":"","text":""},{"title":"Tags","date":"2020-03-01T11:16:12.000Z","updated":"2020-03-01T11:17:05.592Z","comments":true,"path":"tag/index.html","permalink":"http://amb1t10n.github.io/tag/index.html","excerpt":"","text":""}],"posts":[{"title":"Database Note","slug":"Database-note","date":"2021-03-04T12:12:57.000Z","updated":"2021-03-05T09:01:13.618Z","comments":true,"path":"2021/03/04/Database-note/","link":"","permalink":"http://amb1t10n.github.io/2021/03/04/Database-note/","excerpt":"","text":"Chapter 1 1.3 DBMS Major properties of DBMS ( Database Management System ): Efficiency&gt; and scalability (扩展性) in data access Reduced application development time Data independence (physical data or logical data) Data integrity&gt; and security&gt; Concurrent access ( 并发访问 ) and robustness Database system VS File Processing Systems File processing system supported by a conventional OS Drawbacks of using file systems: Data redundancy and inconsistency Difficulty in accessing data Data isolation Integrity problems No atomicity of updates ( atomicity : transfer of funds from one account to another should either complete or not happen at all ) Difficult to concurrent access by multiple users Security problems 1.4 Levels of Data Abstraction Physical level : describes how a record is stored. Files Logical level : describes data stored in database, and the relationships among the data on upper level. View level application programs hide details of data types . Views can also hide information for security purposes. An architecture of a database system Schemas ( 模式 ) and Instances ( 实例 ) Similar to types and variables in programming languages ( type ↔\\leftrightarrow↔ schema ,variable ↔\\leftrightarrow↔instance) Schema :the structure of the database on difference level Analogous to type information of a variable in a program Physical schema : database design of structure at the physical level Logical schema : database design of structure at the logical level Subschema : schema at view level Instance: the actual content of the database at a particular point in time Analogous to the value of a variable 1.5 Data Models Steps of Database Design Requirement analysis What data, applications, and operations needed Conceptual database design A high-level description of data, constraints using E - R model or a similar high level data model Logical database design: Convert the conceptual design into a DB schema Schema refinement Normalization of relations: Check relational schema for redundancies and related anomalies. Physical database design : Indexing, clustering and database tuning Create and initialize the database &amp; Security design Load initial data, testing Identify different user groups and their roles Entity Relationship Model ---- ER 模型 ( 实体-联系 模型) E-R of real word Entities ( objects ) Relationships between entities E-R Model is widely used for database design Database design in E-R model usually converted to design in the relational model Relational Model Transfer E-R diagrams into relational schema 1.6 Database Language DDL : Data Definition Language ( 数据定义语言 ) DML : Data Manipulation Language ( 数据操纵语言 ) DCL : Data Control Language ( 数据控制语言 ) Data Definition Language Specifies a database scheme as a set of definitions of relational schema Also specifies storage structure , access methods and consistency constraints DDL statements are compiled , resulting in a set of tables stored in a special file : data dictionary , which contains metadata Data Manipulation Language Retrieve data from the database Insert / delete / update data in the database query language","categories":[],"tags":[]},{"title":"离散笔记","slug":"离散笔记","date":"2020-05-17T04:17:22.606Z","updated":"2020-05-18T15:42:21.600Z","comments":true,"path":"2020/05/17/离散笔记/","link":"","permalink":"http://amb1t10n.github.io/2020/05/17/%E7%A6%BB%E6%95%A3%E7%AC%94%E8%AE%B0/","excerpt":"","text":"离散笔记 第一章 基础：逻辑和证明 1.1 命题逻辑 命题(Propositions)：一个陈述语句，或真或假不能又真又假，可用字母表示 否命题¬p\\lnot p¬p:p的否定 合取（conjunction）p∧qp \\land qp∧q p且q 析取（disjunction） p∨qp \\lor qp∨q p或q 条件语句:p→qp \\rightarrow qp→q若p则q,等价形式及真值表如下图; 双条件语句:p↔qp \\leftrightarrow qp↔q,等价形式及真值表如下图; 逻辑运算符的优先级： 1.2逻辑命题的应用——语句翻译 “You cannot ride the roller coaster if you are under 4 feet tall unless you are older than 16 years old.” Solution: Let q, r, and s represent “You can ride the roller coaster,” “You are under 4 feet tall,”and “You are older than 16 years old,” respectively. Then the sentence can be translated to (r∧¬s)→¬q(r \\land \\lnot s) \\rightarrow \\lnot q(r∧¬s)→¬q 1.3 命题等价式 定义1：一个真值永远是真的复合命题，称为永真式(tautology),一个命题永远为假的复合命题称为矛盾式(contradiction)。 De Morgan‘s Laws😒\\lnot (p \\and q ) \\equiv \\lnot p \\land \\lnot q $ \\lnot(p \\lor q ) \\equiv \\lnot p \\and \\lnot q p→q≡¬(p∨q)p \\rightarrow q \\equiv \\lnot (p \\lor q)p→q≡¬(p∨q) 逻辑等价式,条件命题的逻辑等价式，双条件的逻辑等价式如下图: 1.4 谓词和量词 量词∀,∃\\forall,\\exist∀,∃比所有逻辑运算符都具有更高的优先级 量词的De Morgan’s Laws:¬∃xQ(x)≡∀x¬Q(x)\\lnot \\exist xQ(x) \\equiv \\forall x \\lnot Q(x)¬∃xQ(x)≡∀x¬Q(x) ¬∀xP(x)≡∃x¬P(x)\\lnot \\forall x P(x) \\equiv \\exist x \\lnot P(x)¬∀xP(x)≡∃x¬P(x) 1.6 推理规则 推理规则建立论证: 第二章 基本结构：集合、函数、序列、求和与矩阵 2.1 集合 定义1：集合是对象的一个无序的聚集，对象也称为集合的元素或成员。集合包含他的元素。用a∈Aa \\in Aa∈A表示，a在集合A中 定义2：两个集合相等当且仅当他们拥有同样的元素。所以，如果A和B是集合，则A和B是相等的当且仅当∀x（x∈A↔x∈B）\\forall x（x \\in A \\leftrightarrow x \\in B）∀x（x∈A↔x∈B）,若A和B是相等的集合，就记为A=BA=BA=B **证明A是B的子集:**若x属于A，则x属于B 证明A不是B的子集：存在一个x属于A，ｘ属于B 证明两个集合相等：A⊆B且B⊆AA \\subseteq B 且B \\subseteq AA⊆B且B⊆A 基数：S 中恰有n个不同的元素，n非负整数，则S为有限集，n是S的基数，记为∣S∣|S|∣S∣ 幂集(power set)：S所有子集的集合，记为P(S)P(S)P(S) 笛卡尔积：A和Ｂ的笛卡尔积用A×BA \\times BA×B表示，是所有的序偶(a,b)(a,b)(a,b)的集合，即A \\times B =\\{ (a,b)| a \\in b \\and b \\in B \\} 2.2 集合运算 并集（union）：A∪B={x∣x∈A∨x∈B}A \\cup B=\\{ x|x \\in A \\lor x \\in B \\}A∪B={x∣x∈A∨x∈B} 交集（intersection）：A \\cap B = \\{ x|x \\in A \\and x \\in B \\} 差集（difference）：A-B=\\{ x| x\\in A \\and x \\notin B\\} 集合恒等式: 2.3 函数 定义1：A和B为非空集合，从A到B的函数fff时对元素的一种指派，对A的每个元素恰好指派B的一个元素。若B中元素b是由函数fff唯一指派给A的元素ａ的，则写成f(a)=bf(a)=bf(a)=b 。如果是A到B的函数fff,就写成f:A→Bf:A \\rightarrow Bf:A→B 一对一函数：函数fff称为是一对一(one to one)或单射函数(injection)，f(a)=f(b)则a=bf(a)=f(b) 则 a=bf(a)=f(b)则a=b 映上函数：函数fff称为是映上（onto）或满射（surjection），对每个$b \\in B 有元素有元素有元素a \\in A 使得使得使得f(a)=b$ 双射：函数fff称为是一一对应（one-to-one correspondance）或双射(bijection),即是单射又是满射。 2.4 序列和求和 几个有用的求和公式 2.5 集合的基数 **定义1：集合A和集合B有相同的基数(cardinality)**当且仅当存在从A到B的一个一一对应。当A和B有相同基数时，写成∣A∣=∣B∣|A|=|B|∣A∣=∣B∣ 可数集：一个集合或者是有限集或者与自然数集具有相同的基数，这个集合就称为是可数的。用阿里夫零ℵ0\\aleph_{0}ℵ0​表示 例：所有整数的集合，奇数集，偶数集，正有理数集是可数的 定理：若A和B是可数集合，则A∪BA \\cup BA∪B可数 Schro¨der−BernsteinSchr\\ddot{o} der-BernsteinSchro¨der−Bernstein定理：若A和B是集合，且∣A∣≤∣B∣|A|\\le |B|∣A∣≤∣B∣且∣B∣≤∣A∣|B|\\le|A|∣B∣≤∣A∣，则∣A∣=∣B∣|A|=|B|∣A∣=∣B∣。换言之，若存在一对一函数fff从A到B和ggg从B到A，则存在A和B之间一一对应的函数 第三章 算法 3.1 算法 算法性质： 输入（input）:算法从指定的集合得到输入值 输出（output）：对每个输入值的集合，算法都要从一个指定的集合中产生输出值。输出值就是问题的解 确定性（Definiteness）：算法的步骤必须是准确定义的 正确性(Correctness)：对每一组输入值，算法都应产生正确的输出值 有限性(Finiteness)：对任何输入算法都应在有限步之后产生期望的输出 有效性(Effectiveness)：算法的每一步都应能够准确地在有限时间内完成 通用性(Generality)：算法过程应该可以应用于期望形式的所有问题，而不只是用于一组特定的输入值 3.2 函数的增长 大O记号：令f,gf,gf,g为从整数集或实数集到实数集的函数。如果存在常数CCC和kkk使得当x&gt;kx&gt;kx&gt;k时就有∣f(x)∣≤C∣g(x)∣|f(x)|\\le C|g(x)|∣f(x)∣≤C∣g(x)∣，则f(x)是O(g(x))f(x)是O(g(x))f(x)是O(g(x))的。O(g(x))O(g(x))O(g(x))可理解为函数集合 例：证明f(x)=x2+2x+1f(x)=x^{2}+2x+1f(x)=x2+2x+1是O(x2)O(x^{2})O(x2)的 解： 0≤x2+2x+1≤x2+2x2+x2=4x2令C=4和g(x)=x2,因此只要当x&gt;1时，就有f(x)=x2+2x+1&lt;4x2.0\\le x^{2}+2x+1\\le x^{2}+2x^{2}+x^{2}=4x^{2}\\\\ 令C=4和g(x)=x^2,因此只要 当x&gt;1时，就有f(x)=x^2+2x+1&lt;4x^2. 0≤x2+2x+1≤x2+2x2+x2=4x2令C=4和g(x)=x2,因此只要当x&gt;1时，就有f(x)=x2+2x+1&lt;4x2. **例：**证明n2n^2n2不是O(n)O(n)O(n)的 **解：**要证明n2n^2n2不是O(n)O(n)O(n)的,则必须证明不存在CCC和kkk使得当n&gt;kn&gt;kn&gt;k时有n2≤Cnn^2\\le Cnn2≤Cn 定理1：令f(x)=anxn+an−1xn−2+...+a1x+a0,其中a0,a1,...,an为实数，那么f(x)是O(xn)的令f(x)=a_nx^n+a_{n-1}x^{n-2}+...+a_1x+a_0,其中a_0,a_1,...,a_n为实数，那么f(x)是O(x^n)的令f(x)=an​xn+an−1​xn−2+...+a1​x+a0​,其中a0​,a1​,...,an​为实数，那么f(x)是O(xn)的 **定理2：**假定f1(xf_1(xf1​(x)是O(g1(x))O(g_1(x))O(g1​(x))的,f2(x),f_2(x),f2​(x)是O(g2(x))O(g_2(x))O(g2​(x))的，那么(f1+f2)(x)(f_1+f_2)(x)(f1​+f2​)(x)是O(max(∣g1(x)∣,g2(x)))O(max(|g_1(x)|,g_2(x)))O(max(∣g1​(x)∣,g2​(x)))的 **定理3：**假定f1(xf_1(xf1​(x)是O(g1(x))O(g_1(x))O(g1​(x))的,f2(x),f_2(x),f2​(x)是O(g2(x))O(g_2(x))O(g2​(x))的，那么(f1f2)(x)(f_1f_2)(x)(f1​f2​)(x)是O(g1(x)g2(x))O(g_1(x)g_2(x))O(g1​(x)g2​(x))的 **大Ω\\OmegaΩ记号：**令f,gf,gf,g为从整数集或实数集到实数集的函数。如果存在常数CCC和kkk使得当x&gt;kx&gt;kx&gt;k时就有∣f(x)∣≥C∣g(x)∣|f(x)|\\ge C|g(x)|∣f(x)∣≥C∣g(x)∣，则f(x)是Ω(g(x))f(x)是\\Omega(g(x))f(x)是Ω(g(x))的。Ωg(x))\\Omega g(x))Ωg(x))可理解为函数集合 **大Θ\\ThetaΘ记号：**令f,gf,gf,g为从整数集或实数集到实数集的函数。如果存在常数CCC和kkk使得当x&gt;kx&gt;kx&gt;k时就有C1g(x)≤∣f(x)∣≤C2∣g(x)∣C_1g(x)\\le |f(x)|\\le C_2|g(x)|C1​g(x)≤∣f(x)∣≤C2​∣g(x)∣，则f(x)是Θ(g(x))f(x)是\\Theta(g(x))f(x)是Θ(g(x))的。Θg(x))\\Theta g(x))Θg(x))可理解为函数集合 做算法复杂度分析时，有最坏情形复杂度，平均情形复杂度 第五章 归纳与递归 5.1 数学归纳法(Mathematical Induction) 数学归纳法可用证明这样一类命题：对所有正整数nnn，P(n)P(n)P(n)为真，其中P(n)P(n)P(n)是命题函数。数学归纳法包含两个步骤：一是基础步骤（BASIS STEP），在基础步骤中证明P(1)P(1)P(1)为真；二是归纳步骤(Inductive Step)，在归纳步骤中证明对所有的正整数kkk，如果P(k)P(k)P(k)为真，那么P(k+1)P(k+1)P(k+1)为真 **例1：**证明nnn是正整数 ，则1+2+3+...+n=n(n+1)21+2+3+...+n=\\frac{n(n+1)}21+2+3+...+n=2n(n+1)​ 数学归纳法证明模板 5.2 强归纳证明与良序性（well-ordering） **原理：**要证明对所有的正整数n而言，P(n)P(n)P(n)为真，其中P(n)P(n)P(n)为命题函数，我们要完成如下两个步骤 基础步骤：证明P(1)P(1)P(1)为真 归纳步骤：P(1),P(2)...P(k)P(1),P(2)...P(k)P(1),P(2)...P(k)为真，则P(k+1)P(k+1)P(k+1)为真 **良序性公理：**任何一个非空的非负整数集合都有最小元素 **例：**用良序性证明整出算法：若aaa是整数且ddd是正整数，则存在唯一的整数qqq和rrr满足0≤r&lt;d0\\le r&lt;d0≤r&lt;d和a=dq+ra=dq+ra=dq+r **解：**设SSS是形如a−dqa-dqa−dq的非负整数的集合，其中qqq是整数。这个集合非空，根据良序性，存在最小元r=a−dq0r=a-dq_0r=a−dq0​ 5.3 递归定义与结构归纳法 递归定义函数： 基础步骤(Basis Step)：规定这个函数在0处的值 递归步骤(Recursive Step)：给出从较小的整数处的值来求当前的值的规则 递归定义的函数是良定义的(well-defined),即对于每一个正整数，函数对应的取值是清楚定义的。 结构归纳法： 基础步骤(Basis Step)：证明对于递归定义的基础步骤所规定的属于该集合的所有元素来说，结果成立 **递归步骤(Recursive Step)😗*证明如果对于定义的递归步骤中用来构造新元素的每个元素来说命题为真，则对于这些新元素来说结果成立。 第六章 计数 6.1 计数的基础 **乘积法则：**假定一个过程可以被分解成两个任务。如果完成第一个任务有n1n_1n1​种方式，在完成第一个任务后有n2n_2n2​种方式完成第二个任务，那么完成这个过程有n1n2n_1n_2n1​n2​种方式 **求和法则：**如果完成第一个任务有n1n_1n1​种方式，有n2n_2n2​种方式完成第二个任务，并且这些任务不能同时执行，那么完成第一或第二项任务有n1+n2n_1+n_2n1​+n2​种方式 **减法法则（两个集合的容斥原理）：**如果第一个任务可以通过n1n_1n1​种方式执行或者可以通过n2n_2n2​种另一类方法执行，那么执行这个任务的方法数是n1+n2n_1+n_2n1​+n2​减去两类方法中执行这个任务相同的方法 **除法法则：**如果一个任务能由一个可以用nnn种方式完成的过程实现，而对于每种完成任务的方式w,w,w,在nnn种方式中刚好有ddd种与之对应，那么完成这个任务的方法数是n/dn/dn/d 6.2 鸽笼原理 **鸽笼原理：**如果k+1个或者更多的物体放入k个盒子，那么至少有一个盒子包含了2个或更多的物体 **广义鸽笼原理：**如果NNN个物体放入kkk个盒子，那么至少有一个盒子包含了至少⌈N/k⌉\\lceil N/k \\rceil⌈N/k⌉个物体SS 6.3 排列组合 **定理1：**具有nnn个不同元素的集合的rrr排列数是P(n,r)=n(n−1)(n−2)...(n−r+1)P(n,r)=n(n-1)(n-2)...(n-r+1)P(n,r)=n(n−1)(n−2)...(n−r+1) **推论1:**若nnn和rrr都是整数，且0≤r≤n0\\le r\\le n0≤r≤n,则P(n,r)=n!(n−r)!P(n,r)=\\frac{n!}{(n-r)!}P(n,r)=(n−r)!n!​ 定理2：若nnn和rrr都是整数，且0≤r≤n0\\le r\\le n0≤r≤n,具有nnn个不同元素的集合的rrr组合数是C(n,r)=n!r!(n−r)!C(n,r)=\\frac{n!}{r!(n-r)!}C(n,r)=r!(n−r)!n!​ 6.4 二项式定理 **二项式定理：**设x和y是变量，n是非负整数，那么 帕斯卡恒等式： 范德蒙德恒等式： 6.5 排列组合的推广 定理1：具有nnn个对象的集合允许重复的rrr排列数式nrn^rnr 定理2：nnn个元素的集合中允许重复的rrr组合有C(n+r−1,r)=C(n+r−1,n−1)C(n+r-1,r)=C(n+r-1,n-1)C(n+r−1,r)=C(n+r−1,n−1),隔板法、 不可区别物体的集合的排列： 可辨别的物体与可辨别的盒子 不可辨别的物体与可辨别的盒子：采用隔板法 可辨别的物体与不可辨别的盒子:数S(n,j)S(n,j)S(n,j)位第二类斯特林数 不可辨别的物体与不可辨别的盒子：自己慢慢分堆，枚举 6.6 生成排列和组合 第八章 高级计数技术 递推关系： 8.2 求解线性递推关系 **定义1：**一个常系数的k阶线性齐次递推关系式形如an=c1an−1+c2an−2+...+ckan−ka_n=c_1a_{n-1}+c_2a_{n-2}+...+c_ka_{n-k}an​=c1​an−1​+c2​an−2​+...+ck​an−k​的递推关系 这个递推关系是线性的，因为它的右边是序列前项的倍数之和。这个递推关系是齐次的，因为所出现的各项都是aja_jaj​的倍数。序列各项的系数是常数，而不是依赖于n的函数 求解常系数线性齐次递推关系 当出现重根时， 常系数非齐次的递推关系 8.4 生成函数 **定义1：**实数序列a0,a1,...,ak,...a_0,a_1,...,a_k,...a0​,a1​,...,ak​,...的生成函数时无穷级数 G(x)=a0+a1x+...+akxk+...=∑k=1∞akxkG(x)=a_0+a_1x+...+a_kx^k+...=\\sum_{k=1}^\\infty a_kx^k G(x)=a0​+a1​x+...+ak​xk+...=k=1∑∞​ak​xk 如：1，1，1，1，1，1的生成函数是1+x+x2+x3+x4+x51+x+x^2+x^3+x^4+x^51+x+x2+x3+x4+x5 **例：**设f(x)=1/(1−x)2f(x)=1/(1-x)^2f(x)=1/(1−x)2,则其生成函数为∑k=0∞(k+1)xk\\sum_{k=0}^{\\infty} (k+1)x^k∑k=0∞​(k+1)xk **定义2：**设uuu是实数且kkk是非负整数。那么广义二项式系数(ur)\\tbinom{u}{r}(ru​)定义为 (ur)={u(u−1)...(u−k+1)k&gt;01k=0.\\tbinom{u}{r}=\\begin{cases} u(u-1)...(u-k+1)&amp;\\text{k&gt;0}\\\\ 1&amp;\\text{k=0}. \\end{cases} (ru​)={u(u−1)...(u−k+1)1​k&gt;0k=0.​ 计数问题与生成函数 **例：**求 e1+e2+e3=17e_1+e_2+e_3=17 e1​+e2​+e3​=17 的解的个数，其中e1,e2,e3e_1,e_2,e_3e1​,e2​,e3​是非负整数，满足2≤e1≤5,3≤e2≤6,4≤e3≤72\\le e_1\\le 5,3\\le e_2\\le 6,4\\le e_3\\le 72≤e1​≤5,3≤e2​≤6,4≤e3​≤7 **解：**具有上述限制的解的个数是 (x2+x3+x4+x5)(x3+x4+x5+x6)(x4+x5+x6+x7)(x^2+x^3+x^4+x^5)(x^3+x^4+x^5+x^6)(x^4+x^5+x^6+x^7) (x2+x3+x4+x5)(x3+x4+x5+x6)(x4+x5+x6+x7) 展开式中x17x^{17}x17的系数 使用生成函数求解递推关系 **例：**求解递推关系ak=3ak−1,k=1,2,3...a_k=3a_{k-1},k=1,2,3...ak​=3ak−1​,k=1,2,3...且初始条件a0=2a_0=2a0​=2 利用生成函数证明恒等式 8.5 容斥 **容斥原理：**设A1,A2,...AnA_1,A_2,...A_nA1​,A2​,...An​是有穷集。那么 ∣A1∪A2∪...∪An∣=∑1≤i≤n∣Ai∣−∑1≤i&lt;j≤n∣Ai∩Aj∣+∑1≤i&lt;j&lt;h≤n∣Ai∩Aj∩Ak∣−...+(−1)n+1∣A1∩A2∩...∩An∣|A_1\\cup A_2\\cup...\\cup A_n|=\\sum_{1\\le i\\le n}|A_i|-\\sum_{1\\le i&lt;j\\le n}|A_i\\cap A_j|+\\\\ \\sum_{1\\le i&lt;j&lt;h\\le n}|A_i\\cap A_j\\cap A_k|-...+(-1)^{n+1}|A_1\\cap A_2\\cap...\\cap A_n| ∣A1​∪A2​∪...∪An​∣=1≤i≤n∑​∣Ai​∣−1≤i&lt;j≤n∑​∣Ai​∩Aj​∣+1≤i&lt;j&lt;h≤n∑​∣Ai​∩Aj​∩Ak​∣−...+(−1)n+1∣A1​∩A2​∩...∩An​∣ 容斥原理的另一种形式: 注：使用隔板法获得每个情况的解 映上函数的个数 定理：设mmm和nnn是正整数，满足m≥nm\\ge nm≥n。那么存在 nm−C(n,1)(n−1)m+C(n,2)(n−2)m−...+(−1)nC(n,n−1)⋅1mn^m-C(n,1)(n-1)^m+C(n,2)(n-2)^m-...+(-1)^nC(n,n-1)\\cdot 1^m nm−C(n,1)(n−1)m+C(n,2)(n−2)m−...+(−1)nC(n,n−1)⋅1m 个从mmm元素集合到nnn元素集合的映上函数","categories":[],"tags":[]},{"title":"物联网安全实验报告","slug":"物联网安全实验报告","date":"2020-04-14T08:08:31.957Z","updated":"2020-04-15T11:48:58.690Z","comments":true,"path":"2020/04/14/物联网安全实验报告/","link":"","permalink":"http://amb1t10n.github.io/2020/04/14/%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/","excerpt":"","text":"物联网安全实验报告 班级：图灵1901 &emsp;&emsp;姓名：张喜瑜&emsp;&emsp;&emsp; 学号：3190104667 【实验背景】 已获得按键数据 matlab 【实验步骤】 一、特征处理 这里选择通过数据统计特征，即均方误差与均值，进行特征提取，将每次按键样本提取为一个6维行向量。 1234567891011121314151617181920212223242526272829303132333435clear;clc;train_of_data=[];%创建训练集tempa=[]; %中介矩阵用于接受返回参数并进行矩阵拼接tempb=[];text_of_data=[];filename=[];filename=['1.csv';'2.csv';'3.csv';'4.csv';'5.csv';'6.csv';'7.csv';'8.csv';'9.csv']; %filename作为参数传入，对每次数据提取训练集与测试集for i=1:9[tempa,tempb]=creat(filename(i,:),i);train_of_data=[train_of_data;tempa];text_of_data=[text_of_data;tempb];end%提取特征函数，分离出训练集和测试集%将每次读取的数据名称与label作为参数传入，返回每个按键训练集和测试集function [train_of_data,text_of_data]=creat(name_of_data,label)data=csvread(name_of_data);%读取文件data(all(data==0,2),:) = [];%消去空行，以时间戳判别两次样本data(:,3:5)=mapminmax(data(:,3:5)')';%归一化train_of_data=[];%创建需要返回的数据矩阵text_of_data=[];cnt=0;%计数训练集集长度i=1;len=0;%计数测试集长度length_data=length(data);%数据行数while(i&lt;=length_data)%双层循环进行样本的截取从而提取特征向量 j=i+1; % while(j&lt;length_data-1) if(data(j,2)&gt;data(j+1,2))%后一个时间戳比前一个小， if(j-i&gt;=6) %则为下一个样本，长度太小则说明时间太 %短，则放弃本次样本 if(cnt/len&lt;4) %选取比例为4：1 train_of_data=[train_of_data;label,mean(data(i:j,3:5)),... mad(data(i:j,3:5))]; %获得特征向量，通过矩阵拼接 cnt=cnt+1; %形成训练集 1234567891011121314 else text_of_data&#x3D;[text_of_data;label,mean(data(i:j,3:5)),... mad(data(i:j,3:5))];%形成测试集 len&#x3D;len+1; end end i&#x3D;j; %下一个样本的行数为j+1 break; %每次迭代i&#x3D;i+1,下次开始为j+1 end j&#x3D;j+1; end i&#x3D;i+1;endend 运行之后获得训练集与测试集， 第一列为按键的键值，2-4列为x,y,zx,y,zx,y,z方向上的均值，5-7列为x,y,zx,y,zx,y,z方向上的均方误差。 二、模型训练 matlab自带机器学习模块，可以直接用于模型建立与训练。 在matlab中打开APP-&gt;Classification learner，新建会话，导入训练集 ，并选择第一列作为分类标签 选择训练方式，这里选择 全部SVM 在左侧历史记录栏中可以看到6中SVM的训练结果选择准确度最高的模型导出。 4.使用导出的模型，获得trainedModel，使用测试集进行验证。 1234567891011%验证代码text=trainedModel.predictFcn(text_of_data(:,2:7));%利用模型进行分类cnt=0; %错误数wrong=zeros(9,1); %计数每个按键错误的次数len = length(text_of_data); %获取测试集长度for i=1 : len if(text(i,1)~=text_of_data(i,1)) cnt=cnt+1; wrong(text_of_data(i,1),1)=wrong(text_of_data(i,1),1)+1; endend 观测结果为 1 2 3 4 5 6 7 8 9 len cnt 准确度 0 3 2 1 2 2 2 1 2 180 15 91.7% 【实验总结】 ​ 本次实验需要运用matlab及机器学习的相关知识，在之前并没有学习过相关知识，对本次实验的进度产生一定影响。 ​ 刚开始时，对实验的诸多方面不太理解，从而无法下手实验，在网上搜索有关于matlab、机器学习与特征处理的相关文章之后，对本次实验有个初步了解，实验的大体步骤为： 将数据进行归一化 选取统计学特征进行特征提取，将每次样本提取为一个多维向量 使用机器学习相关算法建立模型 对这次实验最大的障碍是在第三步，因为不了解SVM的相关算法及模型的建立与识别，看了很久关于SVM算法的介绍与运用，并没有很透彻地理解，但是在网上查到matlab可以直接使用机器学习并建立模型时，一切都迎刃而解。 ​ 总而言之，在这次的实验中，初步了解matlab部分语法及机器学习，收获颇丰。","categories":[],"tags":[{"name":"report","slug":"report","permalink":"http://amb1t10n.github.io/tags/report/"}]},{"title":"buffer overflow","slug":"buffer-overflow","date":"2020-03-31T12:06:33.000Z","updated":"2020-04-14T11:36:07.182Z","comments":true,"path":"2020/03/31/buffer-overflow/","link":"","permalink":"http://amb1t10n.github.io/2020/03/31/buffer-overflow/","excerpt":"","text":"Buffer overflow实验报告 姓名:张喜瑜 学号：3190104667 班级：图灵1901 【实验环境】 Ubuntu 18.04 64bit LTS版本 从学在浙大下载得到32位可执行文件 hw 执行sudo sysctl -w kernel.randomize_va_space=0关闭ASLR 【实验目的】 了解buffer overflow原理 利用buffer overflow改变分支，进行输出 【实验步骤】 一、获得变量地址 打开终端，进入hw所在文件夹 在终端输入，objdump -d hw &gt; hw.asm，生成Linux 32位汇编代码 打开hw.asm，并寻找main函数中定义变量部分 得到isRoot地址为-0xc(%ebp) 二、使用gdb获得ebp及buffer地址 在终端中键入gdb hw 在main函数处设置断点，输入b main 运行hw ,输入r 查看栈基地址,输入p /x \\$ebp，得到$ebp地址为0xffffce98 输入c，继续。得到buffer地址，为0xffffce80 三、计算要overwrite的变量和buffer之间的偏移量 isRoot地址为-0xc(%ebp)，即0xffffce98-0xc==0x8c 与buffer之间的偏移地址为：0x8c-0x80+4=0x10 四、在isRoot处写入0x41424344 Inter80$\\times$86芯片为小端格式，即数据的高字节保存在内存的高地址中，即16进制的41 42 43 44在内存中从高到低，由于写入时为低位到高位，故依次输入44 43 42 41。 由于直接输入44 43 42 41会导致读取8个字节，可输入0x44 ASCII码对应的字符，即D。 输入任意12个字符，再输入DCBA 得到输出：pwded! 【实验结果】 如何获得isRoot地址 由于对汇编语言不太熟悉，在获得ebq地址时，认为ebq地址为isRoot地址，获得偏移地址为0x18-4，输出错误。仔细阅读汇编语言后，发现movl $0x0,-0xc(%ebp)这条指令，猜测-0xc(%ebp)为isRoot地址。 后将源码改为 123456789101112#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void main() &#123; short int isRoot = 0; char buffer[12]; printf(\"the address of buffer is %p \\n\", buffer); gets(buffer); if (isRoot ==0x41424344) &#123; printf(\"pwned! \\n\"); &#125; return;&#125; 再反汇编得到 可以看到 12movl $0x0,-0xc(%ebp) ;变为；movw $0x0,-0a(%ebp) 由此确认-0xc(%ebp)为isRoot地址。 如何了解0x41424344在内存中储存位置 通过网上搜索相关内容，了解到数据的高字节保存在内存的高地址中。 并且通过下列代码证实 123456789#include &lt;stdio.h&gt;int main()&#123; int a=0x41424344; char *p=&amp;a; for (int i=0;i&lt;4;i++)&#123; printf(\"%x \",p[i]); &#125;&#125;//得到输出为44 43 42 41 输入16进制44 43 42 41 实验时通过输入DCBA的方式进行 通过|管道链接,实现输入 12345#include &lt;stdio.h&gt;int main()&#123; printf(\"\\x44\\x43\\x42\\x41\"); return 0;&#125;","categories":[],"tags":[{"name":"report","slug":"report","permalink":"http://amb1t10n.github.io/tags/report/"}]},{"title":"Wireshark抓包实验报告","slug":"wireshark-抓包实验报告","date":"2020-03-31T12:06:33.000Z","updated":"2020-04-14T11:35:58.100Z","comments":true,"path":"2020/03/31/wireshark-抓包实验报告/","link":"","permalink":"http://amb1t10n.github.io/2020/03/31/wireshark-%E6%8A%93%E5%8C%85%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/","excerpt":"","text":"Wireshark抓包实验报告 专业班级：图灵1901 &nbsp; 学号 ：3190104667 &nbsp; 姓名： 张喜瑜 【实验目的】 了解TCP/IP协议下五层协议及其作用。 利用wireshark进行抓包，分析TCP与UDP包，并理解packet headers 是如何被封装的。 了解TCP的三次握手的过程。 【实验步骤】 打开浏览器与Wireshark 在捕获选项中双击选择“以太网”，并开始抓包 在浏览器中打开网站，如 https://www.3dmgame.com/ 停止抓包并分析抓包结果 在过滤器中选择http过滤，并查看过滤结果。选择GET / HTTP/1.1 中记录，右键-&gt;追踪流-&gt;tcp流，查看前三个TCP包中Transmission Control Protocol内容，分析三次握手过程。 再在过滤器中键入udp,双击并查看User Datagram Protcol 中内容。 【实验结果】 TCP/IP协议下五层协议是什么，它们有什么作用？ TCP/IP协议下，从上到下一共有五层：应用层、运输层、网络层、链路层、物理层 应用层：应用层是网络应用程序及它们的应用层协议存留的地方，如HTTP（提供Web文档的请求与传送），SMTP（提供电子邮件报文的传输）和FTP(提供两个端系统之间的文件传送)，由DNS完成域名到比特网络地址的转换。 运输层：运输层在应用程序端点之间传送应用层报文。在因特网中，存在两个传输协议，TCP和UDP，利用其中的任一个都能运输应用层报文。TCP向它的应用程序提供了面向连接的服务。UDP协议向它的应用程序提供无连接服务。 网络层:网络层负责将数据报的网络层分组从一台主机移动到另一台主机。 链路层：通过一系列路由器在源和目的地之间发送分组，实现数据的传递。 物理层：将链路层要移动的帧中的比特一个一个从一个节点移动到下一个节点。这层协议与链路层相关，与实际传输媒体相关，如铜线，光纤，无线电。 举例说明TCP的三次握手是如何实现的？ 我们从下图中可以看到，经过三次TCP包的传输之后，得到了HTTP包。并且我们知道了，客户端的ip address:192.168.1.117,服务器ip address:122.195.200.82 从客户端发送给服务器一个TCP数据包，标志位位[SYN]，Seq=0，表示客户端请求连接。此时服务器确认服务器的接收能力与客户端发送能力正常。 下图为TCP第二次握手的数据包，由服务器发送给客户端，标志位为[SYN，ACK],此时，返回的数据包中，Seq=0,Ack=客户端发送的数据包中Seq+1，即Ack=0+1=1。此时，客户端确认客户端的接收，发送能力与服务器的接收，发送能力正常。 再第三次TCP握手中，由客户端发送给服务器发送确认包，将Ack设置为对方发来的Seq+1，即0+1=1。此时，服务器确认到双方的发送与接收能力正常。 经过三次握手之后，客户端与服务器均确认双方接收与发送数据包的能力正常，可以建立连接。 用一个TCP包与UDP包举例说明packet headers是怎样组成的 如图所示为TCP packet header及12位标志位内容 这是第一次握手时，客户端发送到服务器的TCP数据报，该packet表示请求建立连接，故无确认序号，A/Acknowledgment为0，S/Syn为1. 下图为UDP packet header中内容 再过滤获得UDP数据报时，过滤结果并不只有UDP，还有OICQ、SSDP、MDNS、DNS等等，这些都是基于UDP，故得到不知UDP协议。 对比TCP以及UDP packet header内容，可以发现二者所含内容有较大区别。在搜索相关资料后了解到： TCP与UDP分别给予连接与无连接 TCP能够保证数据正确性，UDP可能丢包 TCP保证数据顺序，UDP不保证 举例说明怎样利用TCP三次握手做DDoS攻击 由于TCP在发送数据段的同时启动一个重传，若在重传超时之前收到Acknowledgment就关闭重传，若没有收到，则重传该数据段。而且TCP保证数据顺序，则可以伪造源IP地址，向服务器发送大量的Syn报文，当服务器回复Syn+Ack报文时，客户端不予回应，使Syn+Ack报文被重传，从而占据半开连接队列，阻止其他用户访问。 重放攻击的原理是怎样的，提供一种可能的防御手段，分析优缺点。 重放攻击的基本原理就是把以前窃听到的数据原封不动地重新发送给接收方，从而达到欺骗系统的目的。 可以采用一次性密钥，每次数据传输的加密密钥均需更改，即使将捕获的数据报重新发送，也达不到目的。 优点：密码只能使用一次，为动态产生，所以不可预测，也只有一次使用有效性，可以有效防御重放攻击。 缺点：若客户端和服务器双方时间不同步或者由于其他网络因素，导致客户端在密钥有效时间内无法输入，导致合法用户无法登录。","categories":[],"tags":[{"name":"report","slug":"report","permalink":"http://amb1t10n.github.io/tags/report/"}]},{"title":"汇编笔记","slug":"汇编笔记","date":"2020-03-23T04:59:54.555Z","updated":"2020-07-24T02:12:20.908Z","comments":true,"path":"2020/03/23/汇编笔记/","link":"","permalink":"http://amb1t10n.github.io/2020/03/23/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0/","excerpt":"","text":"汇编笔记 汇编代码初见及其编译及调试 sum.asm ​ .386 ​ .model flat, stdcall ​ option casemap :none ​ include include\\windows.inc include include\\kernel32.inc include include\\user32.inc includelib lib\\kernel32.lib includelib lib\\user32.lib .data result db 100 dup(0); dup:duplicate重复 ;char result[100]={0}; format db &quot;%d&quot;,0; db:define byte字节类型 ; char format[3]=&quot;%d&quot;; prompt db &quot;The result&quot;,0 .code main: ; 标号 mov eax, 0; ；eax:extended ax，eax是32位寄存器低16位为ax，高16位没名字 mov ebx, 1； 这两句可以相当于是定义全局变量，eax，ebx为寄存器 again: ;函数 add eax, ebx; eax=0+1+2+3 add ebx, 1 ; ebx=4 cmp ebx, 100; cmp:compare jbe again ; jbe:jump if below or equal invoke wsprintf,offset result,offset format,eax invoke MessageBox,0,offset result,offset prompt,0 ret end main; 指定程序的起始执行点 ; end后面的标号决定了程序刚开始 ; 运行时的eip的值。 include include\\***.inc类似与C中引入库函数，在实现输入输出功能 .data为汇编代码的数据段，.code为代码段，变量均在数据段定义。 在代码段中，main:为函数开头，类似于C中main():，但是存在较大差异，main:只是一种标号，可以将其改名为任何形式，但是其后必须存在: invoke相当于是宏定义来调用函数，从后往前将参数输入进函数 wsprintf为函数，后面三个为所需参数，意为：将eax的值以format的形式输入进数组result中，即 wsprintf(result,format,eax)；相当于C中这种形式 转化为汇编语言 push eax push offset format push offset result call wsprintf add esp 0Ch 最后一步清除堆栈，0Ch为12，即上面三条push 同理， invoke MessageBox,0,offset result,offset prompt,0 输入MessageBox所需的参数，最后的0 ，为弹出窗口的格式，即最简单的格式:只有一个“OK”按钮，prompt为弹窗的名称，result需要显示的字符串，最前面的数字为父弹窗的所属关系，0为不依靠任何窗口，即独立。offset为取址，即&amp; 编译与调试 对与32位windows系统，需要先打开qeditor，后打开所要编译文件，project-&gt;build all，弹出生成.exe文件即可，可在相应文件夹打开或者project-&gt;run program打开生成程序。 32位的windows进行调试，需要将生成的.exe文件，拖入Ollydug中，在OD中打开后，F2设置断点，F8单步进行，F7进入函数，双击汇编代码或者机器语言可将其修改，但是本次修改只能在本次进行中保存。 浮点数的二进制表示 IEEE754规则 第一位为符号位，1为负数，0为非负数 后八位为偏置指数，得出结果-127获得实际指数 再将后面23位抄下，在最左边加上 1. 即1.1111110 11000000 00000000 再将小数点向右移 实际指数 位，即6位 小数点前为整数，小数点后为小数位 加法，位运算 add (sub与add相同） add 加法操作符，可进行： add 寄存器，寄存器如 add ax,bx add 寄存器，变量 如 add ax,ds:[1000h] add 寄存器，常数 如 add ax,1 add 变量，寄存器 如：add ds:[1000h],ax add 变量，常数 如：add word ptr ds:[1000h] ,2 ptr 相当于强制类型转换，类似的有 byte ptr``dword ptr word ptr add 变量，变量语法错误：因为CPU不支持同时操作两个内存变量 想要实现变量和变量的加法，可以使用如下方式 mov ax,x add y,ax 其效果等同于y+=x; 同时 mov ax ,bh 语法错误，因为左右不等宽 设ds=1000h,执行add word ptr ds:[0],2 地址 值 1000:0 0FEh 1000:1 0FFh 1000:2 0FFh 1000:3 01h word为两字节，则word ptr ds:[0]==FFFE,加2后，变为 地址 值 1000:0 00h 1000:1 00h 对于byte ptr则变为 地址 值 1000:0 00h 1000:1 0FFh 强制类型转换之后，限定了ds:[0]所占据的比特。 逻辑运算 Test 123mov ax,9234htest ax,8000h;内部做and但不将结果保存在ax中jnz mab_is_one;most significant bit 最高位，test和and的关系相当于从cmp和sub的关系 and 和 add ax,bx 等同 ax=ax&amp;bx or 或 or ax,bx 等同 ax=ax|b xor 异或 xor ax,bx 等同 ax=ax^bx not 非 not ax 等同 ax=~ax shl 左移 shl ax,bx 等同 ax=ax&lt;&lt;bx shr 右移 shr ax,bx 等同 ax=ax&gt;&gt;bx rol循环左移 rol ax,1 等同 ax =_rol(ax,1) ror循环右移 ror等同 ax =_ror(ax,1) mov ah,101110110B rol ah,1;AH=0110 1101=6Dh mov ah,10110111B ror ah,1;AH=1101 1011=0DBh 在编程时引用一个16进制常数时，若恰好是以字母开头，则不仅要加后缀h,还需要加前缀0 rcl,rcr带进位左移右移 sal==shl 算术左移等于逻辑左移 sar！=shr sar对负数右移时左边要补1：针对符号数 位运算作用 可使某些位变0 如： 1111 0000 用 0000 1111 and 变为 0000 0000 用or使某些位变1 用xor反转某些位 在数据段之前，加入.386,data segment，code segment后加入use 16可使用32位寄存器。 利用循环左移转换进制 判断是否为0 text cl,cl or cl,cl and cl,cl or cl,0 cmp cl,0 每条指令后都可跟jz或jnz判断 段地址 物理地址:用一个整数表示的地址称为物理地址，例如：12398h 假定在程序中要引用地址12398h指向的字节 1mov al,[12398h] ;可以理解为al&#x3D;*(char *)0x12398 在8086CPU中，寄存器均为16位，如：ax,bx,cx,dx,sp,bp,si,di,FL,IP,cs,ds,es,ss 其中bx,bp,si,di用来表示地址。 12mov bx,12398h ;语法错误，12398h超过16字节mov al,[bx] mov al,[12398h]尽管用常数地址来引用，但是语法错误，[]中值必须为16位。 位于同一个段，物理地址的段首地址相同。段首地址:偏移地址，形如此类称为逻辑地址。 对于mov al,[12398h]可改为如下代码： 123mov dx,1000hmov ds,dxmov al,ds:[2398h];但是mov al,1000h:[2398h]错误 对于mov bx,12398h可改为 1234mov dx,1000hmov es,dxmov bx,2398hmov al,es:[bx] 段起始地址的二进制低四位，即16进制的个位必须=0 段的最大长度位10000h字节 一个物理地址可以表示成多个逻辑地址，例如：12398h=1234:0058=1235:0048 段地址的1相当于偏移地址的10h，+1，偏移地址-10h，-1，偏移地址+10h 程序中引用某个变量是，该变量的段地址不能用常数表示，必须用段寄存器如：cs，ds，es，ss的其中之一。 段地址:偏移地址可以表示20位的物理地址。在8086系统中，地址线只有20条，即最多只能寻址1M的内存空间，所以dos系统只能访问1M内存空间。 将1000h:0000起长度为128k的内存全部填为0： 123456789101112131415mov ax,1000hmov dx,2;块数next_block:mov ds,axmov bx,0mov cx,0next_byte:mov byte ptr ds:[bx],0add bx,1sub cx,1;0-1&#x3D;&#x3D;FFFF!&#x3D;0,ffff 64kjnz next_bytemov ax,dsadd ax,1000hsub dx,1jnz next_block 16位的CPU工作在实模式(real mode)，32位工作在保护模式(protected mode)下。在实模式下，用户程序具有跟操作系统一样的权限，可以执行任何指令；保护模式下，用户程序的权限低于操作系统，有些特权指令无法执行。 间接寻址 可以用寄存器、寄存器+常数表示变量的偏移地址如[bx],[si+2],[bx+si+2],[bp+1] 常数可以是负数 两个寄存器只能相加，不能相减 两个寄存器只能从b开头选一个，i结尾选一个。 32位间接寻址方式 [寄存器+寄存器*n+常数]其中n=2、4、8. 例如： 12345mov eax,[ebx+esi*4];设ebx位数组a的首地址，下标i用esi表示，则上述语句相当于C的eax&#x3D;a[i];long a[4]&#x3D;&#123;1,2,3,4&#125;,y;y&#x3D;a[2];mov y,[ebx+esi*4];4&#x3D;sizeof(long int)mov eax,[ebx+esi*4+6] 32位寻址方式中，对[]中的两个寄存器几乎不加限制 ebx,ebi.esi,edi,eax,ecx,edx,esp,任意两个寄存器可以相加，甚至相同。 ptr 修饰变量： byte ptr==char * 1字节 word ptr==short int * 2字节 dword ptr == long int* 修饰标号： near ptr 近，当前指令与目标地址在同一段 far ptr 远 near ptr 和far ptr 前面通常是jmp或call jmp far ptr away 表示远跳，jmp与code不在同一段内。 当源操作数为常数，目标操作数为变量时，则变量必须加上类型修饰。 assume 作用 帮助编译器建立段寄存器与段得关联，当源程序中引用了某个段内的变量时，编译器会在编译出来的机器码中把变量的段地址替换成段内关联的寄存器。 图形模式编程 写入B800段内的显卡内存来控制屏幕输出时文本模式编程 内存映射（mapping）：例如把显卡内存和RAM中的B800段建立对应关系 A000段开始到F000均不是用户的内存空间，有部分内存时映射在显卡内存中，有部分内存映射在ROM中。 POST（Power On Self Test）位于ROM中，映射到F000段中。 DOS中留给用户的内存仅有0000:0000~9000:FFFF这块640K内存。 如何把显卡切换到图形模式（graphics mode）：调用int 10h中断 要切换到分辨率320*200，颜色256色的图形模式： mov ah,0 ;其中AH=0表示子功能号为0 mov al,13h;其中AL=13h代表图形模式编号 int 10h;int 10h是与显示相关的bios中断 int 21h实际是dos系统的内核，其代码是微软写的，代码是保存在磁盘上的。 int 10h 是BIOS（Basic Input Output System）的一部分，其代码是主板的厂家写的。保存在ROM里面。 ss:sp及堆栈段 堆栈段的定义及使用： 123456stk segment stack;段名无关紧要db 200h dup(&#39;S&#39;);定义无名数组 ;或写成dw 100h dup(0)stk ends;堆栈空间是stk:0到stk:1FF;程序开始运行时，ss&#x3D;stk,sp&#x3D;1FF+1 程序开始运行时，ds=es=psp段址，其中psp表示程序端前缀，他位于程序首个段的前面，长度为100h字节。psp种存放了与当前exe有关的信息如psp:80h开始存放了exe的命令行参数。 程序运行时，dos会把exe文件包含的机器码复制到内存中，并且手段前面会自动分配给一块长度为100h字节的内存给psp段。 dos自动对段寄存器作赋值：ds=es=psp 再赋值ss:sp=堆栈段址：堆栈长度 再赋值cs:ip=代码段址：main的偏移地址 如果源程序中没有定义堆栈段，dos会自动分配一个堆栈段给exe，其中ss=首段的段地址，sp=0 12push ax; sp &#x3D; sp -2&#x3D;FFFEpop ax; es es:extra segment 附加段 与ds类似 AX BX CX DX；计算；BX可以用来表示偏移地址 SP BP SI DI; FL 标志寄存器 FL共16位，但只用其中9位，包括6个状态标志和3个控制标志 O D I T S Z A P C 12345cmp cf,1;语法错误;可以用一下指令jc cf;进位则跳jnc cfadd ah,0;ah&#x3D;ah+0+cf使用ah判断值 与cf相关的两条跳转指令：jc,jnc,clc,stc,cmc clc;使cf=0 stc;使cf=1 cmc;使cf相反 ZF 零标志 用于刚刚的计算是否为0，若为0，则ZF=1 jz和jnz指令与ZF相关。跳转的依据为ZF是否为1. jejz,jnejnz mov指令不干扰标志位 SF 标志符号 SF为结果最高位值，负数为1，非负数为0 jns与js为跳转指令。 OF 溢出标志 正正相加为负 或 负加负为正。 正加负永不溢出。 jo与jno为相关指令。 非符号数加法也有溢出： 123mov ah,0FFhadd ah,1;AH&#x3D;0,CF&#x3D;1 可以把CF当作非符号数的溢出标志 ;OF&#x3D;0 标志位 ：PF，AF，DF，IF，TF （1）、PF奇偶标志和AF辅助进位标志 PF：运算结果低八位中1的个数为偶数则为1，否则为0 jp 当PF=1时则跳，jp也可以写成jpe(even) jnp 当PF=0时则跳，jnp也可以写成jpo（odd） AF：低4位向高4位产生进位或借位。 AF没有相关的跳转指令，但有相关的BCD计算指令，如daa(decimal adjust for add),aaa(ascii adjust for add) AF 跟BCD(Binary Coded Decimal)码有关 使用19h表示19，11h表示11，有利于取各位 12345619：1119h:11h19h &gt;&gt; 4 o1h 十位19h &amp; 0Fh 09h 个位11h+9&#x3D;1Ah 需要调整，只要+6即可;此时AF&#x3D;111h+0Fh&#x3D;20h 123mov al,11hadd al,9daa ; AL&#x3D;20h，daa只对AL中的值进行调整。 CF ZF SF OF AF PF 为状态标志 DF TF IF：为控制标志 DF：direction flag TF：trace/trap flag IF：interrupt flag (2)DF方向标志，控制字符串的操作方向。 DF=0时为正方向（低地址到高地址），DF是反方向。 cld使DF=0，std使DF=1 部分重叠时： 若源首地址&lt;目标首地址,则复制按反方向。 当源首地址&gt;目标首地址,复制时按正方向。 （3）、IF中断标志 当IF=1时，允许中断，否则禁止中断。cli指令使IF表示关 sti指令使IF表示计算机硬件向CPu发出中断请求。 允许中断时允许计算机硬件向cpu发出中断请求 12345678mov ax,0mov bx,1next:add ax,bx;若此则CPU则cpu，插入到int 9h指令中，读键盘编码并保存到键盘缓冲区中;硬件中断是由某个事件如用户敲键触发的，而不是程序员写int指令实现的。add bx,1cmp bx,100;若程序已经运行了1&#x2F;18秒，则cpu会子啊此处插入一条int 8hjbe next 使用cli和sti把一段代码包围起来可以达到该段代码在执行过程中不会被打断的效果。 端口 如何定义一个函数并调用它？ 用标号定义 12345678910111213f: inc ax retmain: mov ax,3 call fexit: mov ah,2 mov dl,al add al,&#39;0&#39; int 21h;调用返回值 mov ah,4Ch int 21h 用proc定义 1234f proc;procedure 过程，可以理解为函数(function) inc ax retf endp;end of procedure 端口编号就是端口地址。范围是:[0000h,0FFFFh],共 65536个端口。 对端口的操作指令in与out实现，端口地址与内存地址无关。计算机语言有高级低级之分。汇编语言中要实现同样的功能 ，其代码也有高级低级之分。 dos级别（高级）,不能读取F1~F12，也不能读取PgUp等 1234char c;c&#x3D;getchar();scanf(&quot;%c&quot;,&amp;c);mov ah,1int 21h bios级别(中级) TC中有一个BIOS级别的读键函数 12unsigned short int key;key&#x3D;bioskey(0); 能读取F1~F12，方向键等 12mov ah,0int 16h; 端口级别(低) TC中可以调用key=inport(0x60);读取键 in al,60h;端口级别的变成能够读到Ctrl 让硬盘的磁头移动到0道/0头/1扇区并读取该扇区的内容： bios 123456789mov ah,2mov dl,80h;Cmov dh,0;0头mov ch,0;0道mov cl.1;1扇区mov ax,seg bufmov es,axmov bx,offset bufint 13h 端口 有许多out/in 指令 段跨越 当[]中包含有寄存器bp时，该变量的段地址 一定是ss。 默认的段地址可以改变，如 mov ax,[bp+2]-&gt;mov ax,ds:[bp+2] 这条指令的源操作数段地址从默认的ss变成了ds 这种情况称为段跨越。 指令 mov 1234mov byte ptr ds:[bx],byte ptr es:[di];错误原因，两个操作数不能同时为内存变量。;以下为正确方式mov al,es:[dl]mov ds:[bx],al push pop push、pop遵循先进后出的规则。push与pop后不能跟一个8位的寄存器或变量： 12push ah pop al;均错误push byte ptr ds:p[bx] 8086中，push不能跟一个常数，但80386及以后的cpu允许push一个常数。 xchg 1234mov ax,1mov bx,2xchg ax,bx;交换xchg ax,ds:[bx] div (1). 16位除以8位得8位 ax/除数=AL.........AH。被除数一定是ax 例如，AX=123h,BX=10h 12div bh;AL&#x3D;12h,AH&#x3D;3h;fdiv 做小数除法 (2). 32位除以16位得16位 dx:ax /除数= ax…dx 例如：div bx 设dx=123h,ax=4567h,bx=1000h div bx;1234567h/1000h=&gt;AX=1234h,dx=0567h (3).64位除以32位得32位 edx:dax /除数=eax…edx 例如：div ebx 假定要把一个32位整数如7FFFFFFFh转换为十进制格式，则一定要使用（3）这种除法防止发生除法溢出。 除法溢出时： 会在div指令前面插入int 00h,但这条指令再内存中不存在 地址传送指令：LEA，LDS，LES (1). lea dest,src load effective address =取变量的偏移地址。 lea dx,ds:[1000h]; mov dx,1000h;两条指令效果相同 lea dx,abc; mov dx,offset 1000h; mov dx,offset ds:[bx+si+3];语法错误 lea dx,ds:[bx+si+3];dx=bx+si+3 mov dx,bx+si+3;错误 mov dx,1+2+3;正确用法 mov dx,((1*2+3) shl 2 ) xor 5;正确 lea eax,[eax+eax*4] lea eax,[eax+eax*2];EAX=EAX *3 （2）.远指针 16位汇编中，远指针式指16位段地址：16位偏移地址 32位汇编中，远指针式指16位段地址：32位偏移地址 48位的远指针在汇编语言中有一个类型修饰词： fword ptr 近指针：偏移地址就是近指针 16位汇编中，近指针是指16位偏移地址 PUSHF,POPF(把标志寄存器FL压入堆栈/弹出堆栈) 有些寄存器不能用来作为push/pop的操作数 push FL及pop FL均为错误用法 push IP 及pop IP也是错误用法 push cs正确，但是pop cs错误，因为cs不能用mov、pop指令改变，只能通过jmp、call、int指令间接改变。 事实上，任何指令均不能引用FL，IP这两个寄存器。 ip的值跟cs类似，需要通过jmp、call、int指令简介改变。jmp 1234h将ip改为1234h（隐式改变） 12345;p堆栈sh FL，不能写成push FLpop ax;ax&#x3D;FLor ax,100h;1 0000 0000Bpush axpopf ;FL&#x3D;ax 在32位系统中，EFL是一个32位寄存器，对应的指令是pushfd和popfd；若在32位系统中使用pushf/popf则控制的是EFL的低16位 符号扩充指令：CBW，CWD，CDQ cbw:convert byte to word cwd:convert word to double cdq:convert double to quadruple word 被扩充的一定为ax mov al,0FEh cbw；把AL扩充为AX，ax=0FFFEh mov ax,8000h cwd;把ax扩充成dx:ax,dx=FFFFh,ax=8000h mov eax,0ABCD1234h cdq;把eax扩充成edx:eax ​ ;edx=0FFFFFFFFh,eax=0ABCD1234h 要计算-2/2 12345mov al,-2cbw;ah &#x3D;0FFh,al&#x3D;0FEhmov bl,2idiv bl;idiv表示符号数除法 ;al&#x3D;0FFh,ah&#x3D;0 乘法指令mul (imul可做符号数的乘法) 8*8=16 被乘为AL，乘积为AX 16*16=32 被乘为AX，乘积为DX:AX 32*32=64 被乘为EAX，乘积为EDX：EAX imul的第二类用法可以包含2-3个操作数 imul eax,ebx;eax=eax*ebx imul eax,ebx,3;eax=ebx,3,这种用法第三个操作数只能是常数 换码指令：XLAT(translate)也称查表指令 在xlat执行前必须让ds:bx指向表，al必须赋值为数组的下标；执行xlat后，al=ds:[bx+AL] 设ds=数组的段地址 12345mov ax, seg tmov ds,axmov bx,offset tmov al,10;al为下标xlat;结果al&#x3D;ds:[bx+al] 算术指令 (1)加法指令：add,inc,adc inc:increment mov ax,3 inc ax;ax=ax+1=4 inc指令不影响CF标志位，add影响CF adc:带进位加 计算12345678h+5678FFFFh 1234mov dx,1234hmov ax,5678h;ds:ax&#x3D;12345678hadd ax,0FFFFhadc dx,5678h;dx&#x3D;dx+5678h+cf (2)减法指令:sub,sbb,dec,neg,cmp dec为自减，不影响cf neg:negate求相反数，会影响cf,zf,sf等标志位 mov ax,1 neg ax;ax=-1=0FFFFh,相当于做减法0-ax sbb：带借位减 求56781234h-1111FFFFh差 mov ax,1234h sub ax,0FFFFh;cf=1 mov dx,5678h sbb dx,1111h;dx=5678-1111h-cf ja,jb,jae,jbe是非符号数的相关跳转指令 jg,jl,jge,jle是符号数比较的相关跳转指令 jg:SFOF且ZF0 jge:SF==OF jl:SF!=OF jle:SF!=OF或（SFOF且ZF1） 小数运算 fadd,fsub,fmul,fdiv(387指令)小数的±*/运算指令，fld载入浮点数，fild载入整数 小数变量的定义： 1234pi dd 3.14;32位小数，相当于floatr dq 3.14159;64位小数，相当于double ;q:quadruples dt 3.14159265;80位小数，相当于longdouble CPU内部有8个小数寄存器，分别叫做 st(0),st(1)…st(7),宽度均为80位小数，st(0)可简化为st fstp xxx，保存结果到xxx中，并弹出st(0) fild，表示载入的值为整数，需将其以小数的形式保存 intel为了对向量运算进行加速，发明了mmx、sse、avx指令 mmx：multi-media extension有64位寄存器 sse:streaming simd extension 128寄存器 avx:advanced vector extension,256寄存器 simd:single instruction multi-data， 最新的交avx512指令，里面配套的寄存器有512位 字符串操作指令 字符串传送指令：movsb,mobsw,movsd rep movsb;repeat mov string by byte 准备工作: ds:si-&gt;源字符串(si 就是 sourse index,) es:di-&gt;目标字符串(di 就是 destination index) cx=移动次数(repeat次数) DF=0即方向标志设成正方向(用指令cld) 12345678910if (cx&#x3D;&#x3D;0) goto donebyte ptr es:[si]&#x3D;byte ptr ds:[si]if(df&#x3D;&#x3D;0) si++;di++;else si--;di--;cx--goto againdone 单独执行movsb指令 12345byte ptr es:[si]&#x3D;byte ptr ds:[si]if(df&#x3D;&#x3D;0) si++;di++;else si--;di--; 12345678910111213141516171819202122232425262728293031323334353637383940### 字符串比较指令：cmpsb,cmpsw,cmpsdcmpsb:比较byte ptr ds:[si]与byte ptr es:[di]df&#x3D;0时，si++,di++ df&#x3D;1时，si--,di--repeat if equal 本次相等**repe cmpsb**（若本次比较相等则比较下一个**）****repne cmpsb** (若本次比较不等则继续比较下一个)根据ZF&#x3D;1推出双方全等，表示循环结束后最后一次双方全等je 表示全等### 字符串扫描指令 scasb，scasw，scasdscasb:​ cmp al,es:[di]​ di++;当DF&#x3D;1时，di--repne scasb:&#96;&#96;&#96;assemblynext: if(cx&#x3D;&#x3D;0) goto done; cmp al es:[di] di++;cx--;je donegoto donedone 字符串操作指令 stosb与lodsb store stosb: 12345678;将1000:10A0开始共100h个字节内存单元全部填0mov ax,1000hmov es,axmov di,10A0hmov cx,100hcldxor al,alrep stosb lodsb 123AL&#x3D;DS:[SI]SI++;DF&#x3D;&#x3D;1-&gt;SI--;lodsb通常没有rep 12345678910;例如：设ds:si-&gt;&#39;##AB#12#XY&#39;,过滤&#39;#&#39; cld again: lodsb; cmp al,&#39;#&#39; je next stosb next: dec cx jnz again 控制转移指令:jmp call int jmp 123jmp short target ;短跳(1字节),所有的条件跳转指令都是短跳jmp near ptr target;近跳(2字节)jmp far ptr target;远跳(4字节) 短跳太远跳不过去的解决方法: 1234567cmp ax,bxje equal;改为jne not_equal ; jmp equalnot_equal:....;equal:... 近跳的三种格式 jmp 偏移地址或标号 jmp 16位寄存器 jmp 16位变量 远跳的两种格式 jmp 段地址 jmp dword ptr 32 位变量 循环指令：loop loop dest 的操作过程 cx=cx-1 if(cx!=0) ​ do 123456jcxz done;防止cx为0进入循环,next:add ax,cxdec cx;cx&#x3D;0时，循环10000h次jnz next;done: call，ret指令 使用call时，cpu会把下条指令的偏移地址压入堆栈 ret时，cpu会从堆栈中弹出一个字，并把此字赋值给ip 远调用：call far ptr 或call dword ptr 、在调用时，cpu会先压入下条指令的段地址即cs，再压入下条指令的偏移地址即offset next,最后jmp far ptr 远返回:retf,cpu会先做pop ip，再pop cs 32位系统下的远调用： call far ptr或call fword ptr [abc]，表示abc里面保存了48位的远指针 汇编语言中的三种参数传递方式 寄存器传递法 123456789f: add ax,ax retmain: mov ax,e call fnext: mov ah,4Ch int 21h 变量传递(不支持多线程) 1234567f: mov ax,var add ax,ax retmain: mov var,3 call f 堆栈传递 1234567891011f: push bp mov bp,sp;此两句可构造堆栈框架 mov ax,[bp+4] pop bp retmain: mov ax,3 push ax call f add sp,2 动态变量 123456f: push bp mov bp,sp sub sp,2 mov ax,[bp+4] add ax,[bp+6] int、iret int 21h对应的函数首地址保存在0：84h处，该地址时一个远指针。 dword ptr 0:[84h]称为int 21h的中断向量（其实是他的函数首地址） int n对应的中断向量的存储位置一定是0:n*4 n的范围是[00,FF],所以256个中断向量会占用0:0~0:3FF之间龚400h个字节内存，这块区域称为中断向量表。 中断向量的初始化由BIOS(int 10h,int 16h,int 13h,int 8,int 9等)及dos(int 21h)负责填入 用户可以修改中断变量，但改的时候通常需要保存原来的中断变量，以便让代码与老代码链接起来。 混合语言编程 C源代码嵌入汇编指令 把.c和.asm分别编译成.obj, 再通过link把两个.obj加起来生成.exe","categories":[],"tags":[]},{"title":"Note of Discrete Mathematics and Its Applications","slug":"page","date":"2020-03-01T08:00:48.000Z","updated":"2020-03-02T07:58:48.914Z","comments":true,"path":"2020/03/01/page/","link":"","permalink":"http://amb1t10n.github.io/2020/03/01/page/","excerpt":"","text":"Chapter 1 1.1 propositional logical命题逻辑 Proposition**【Definition】**：A proposition is a declarative sentence that is either true or false, but not both. 例如： 1+1=2 华盛顿特区是美利坚合众国的首都are True propositions 2+3=1is false proposition Notice：The assert The statement is false proposition is not a proposition. Because no matter what the truth value is,there is a contradition. 1.2 Logical operators 1 Negation(NOT)¬\\lnot¬ **【Definition】**Let ppp be a proposition.The negation of p,¬p\\lnot p¬p is the proposition&quot;It is not the case that ppp&quot; Example: ppp:Michael’s PC runs Linux¬p\\lnot p¬p:Michael’s PC does not run Linux 2. Conjunction(AND)⋀\\bigwedge⋀（和取） 【Definition】:Let ppp and q be propositions. The conjunction of ppp and qqq, denoted by p⋀qp \\bigwedge qp⋀q, is the proposition “ppp and qqq.” The conjunction p⋀qp \\bigwedge qp⋀q is true when both ppp and qqq are true and is false otherwise. Example :I have an apple and a pencil. 3. Disjunction(OR)⋁\\bigvee⋁（析取） **【Definition】**Let ppp and qqq be propositions. The disjunction of ppp and qqq, denoted by p⋁qp \\bigvee qp⋁q, is the proposition “ppp or qqq.” The disjunction p⋁qp \\bigvee qp⋁q is false when both ppp and qqq are false and is true otherwise. 4. Exclusive or(XOR)⨁\\bigoplus⨁（异或） 【Definition】:p⨁qp \\bigoplus qp⨁q is ppp or qqq but not both. 5. Conditional(IF–THEN)→\\rightarrow→ **【Definition】**The conditional statement p→qp \\rightarrow qp→q is the proposition “if ppp, then qqq.” p→qp \\rightarrow qp→q can be exprssed as: 6. Biconditional(IF AND ONLY IF)⟷\\longleftrightarrow⟷ 【Definition】:Let ppp and qqq be propositions. The biconditional statement p↔qp \\leftrightarrow qp↔q, is the proposition “ppp if and only if (iff) qqq.” p⟷qp \\longleftrightarrow qp⟷q can be exprssed as: 7.Precedence of Logical Operators | operator | precedence | |-------------------|-- ----------| | lnot\\\\lnotlnot | 1 | | ⋀\\bigwedge⋀ | 2 | | ⋁\\bigvee⋁ | 3 | | →\\rightarrow→ | 4 | |↔\\leftrightarrow↔ | 5| 8.Truth table xxx yyy ¬x\\lnot x¬x xbigwedgeyx \\\\bigwedge yxbigwedgey xbigveeyx \\\\bigvee yxbigveey xbigoplusyx \\\\bigoplus yxbigoplusy xleftarrowyx \\\\leftarrow yxleftarrowy xleftrightarrowyx \\\\leftrightarrow yxleftrightarrowy T T F T T F T T F T T F T T T F T F F F T T F T F F T F F F T T Translating English sentences Example:Translate You can access the Internet from campus only if you are a computer science major or you are not a freshman Solution: Let aaa:you can access the Internet from campus ccc:you are a computer science major fff:you are a freshman This sentence can be represented as a→(c⋁¬f)a \\rightarrow (c \\bigvee \\lnot f)a→(c⋁¬f) 1.3 Logical Equivalences 【Definition】:The compound propositions p and q are called logically equivalent if p↔p \\leftrightarrowp↔ is a tautology. Notation:p≡qp \\equiv qp≡q or p⇔qp \\Leftrightarrow qp⇔q NOR:The proposition p NOR q is true when both p and q are false, and it is false otherwise. The operator ↓\\downarrow↓ is called Peirce arrow. 1.4 Predicates and Quantifiers 1.5 Nested quantifiers nested quantifiers A statement can have multiple variables 【Definition】:Two quantifiers are nested if one is within the scope of the other. Example:Let C(x,y)denote &quot;x has taken course y&quot;where the domain of x and y consist of all ZJU students and all CS courses. ∀x∃yC(x,y)\\forall x \\exists y C(x,y)∀x∃yC(x,y) :Every student at ZJU has taken some CS course. ∃x∀yC(x,y)\\exists x \\forall y C(x,y)∃x∀yC(x,y) :Some student at ZJU has taken all CS courses. Translate: Translate the statement ∀x(C(x)⋁∃y(C(x)⋀F(x,y)))\\forall x(C(x) \\bigvee \\exists y(C(x) \\bigwedge F(x,y)))∀x(C(x)⋁∃y(C(x)⋀F(x,y)))into English,where C(x)C(x)C(x) is “x has a computer,”F(x)F(x)F(x) is &quot;x and y are friends&quot;and the domain for both x and y consists of all students at ZJU. Solution::Every student at ZJU has a computer or has a friend who has a computer. Express the statement “Everyone has exactly one best friend” as a logical expression with a domain consisting of all people. Solution:“For every person x,x has exactly one best friend”⇒\\Rightarrow⇒“There is a person y who is the best friend of x,and furthermore,that for every person z,if z is not y,then z is not the best friend of x.” Let B(x,y)B(x,y)B(x,y) be the statement “y is the best friend of x” $\\forall x \\exists y \\forall z (B(x,y) \\bigwedge ((z \\neq y)\\rightarrow \\lnot B(x,z)))$ The order of quantifiers the order of nested quantifiers matters if quantifiers are different types: $\\forall x \\forall y \\equiv \\forall y \\forall x$ $\\exists x \\forall yP(x,y) \\neq \\forall y \\exists x P(x,y)$ Negating Nested quantifers Negating nested quantifiers by successively applying the rules for negating statements involving a single quantifier. Example: Express the negation of the statement ∀x∃y(xy=1)\\forall x \\exists y (xy=1)∀x∃y(xy=1) so that no negation precedes a quantifiers. Solution:¬∀x∃y(xy=1)≡∃x(¬∃(xy=1))≡∃x∀y(¬(xy=1))≡∃x∀y(xy≠1)\\lnot \\forall x \\exists y (xy=1) \\\\ \\equiv \\exists x(\\lnot \\exists (xy=1)) \\\\ \\equiv \\exists x \\forall y (\\lnot (xy=1)) \\\\ \\equiv \\exists x \\forall y (xy \\neq 1)¬∀x∃y(xy=1)≡∃x(¬∃(xy=1))≡∃x∀y(¬(xy=1))≡∃x∀y(xy​=1) Propositional Normal Forms Literal:ppp ororor ¬p\\lnot p¬p 【Definition】:Disjunctions(conjunctions) with literals as disjuncts are calles is djunctions(conjunctions) clauses.Disjunctive and conjunctive clauses are simply called clauses. Examples: q∨rq \\lor rq∨r Disjunctive clause ¬q∧p\\lnot q \\land p¬q∧p Conjunctive clause p∧q∨rp \\land q \\lor rp∧q∨r Not a clause Conjunctive Normal Form(CNF) 【Definition】 A conjunction with disjunctive clauses as its conjuncts is said to be in conjunctive normal form. Examples: p∧(q∨r)p \\land (q \\lor r)p∧(q∨r) T ¬q∧p\\lnot q \\land p¬q∧p T p∧((p∧q)∨rp \\land ((p \\land q) \\lor rp∧((p∧q)∨r F Disjunctive Normal Form(DNF) **【Definition】**A disjunction with conjunctive clauses as its disjuncts is said to be in disjunctive normal form. Examples: (p∧q)∨(p∧¬q)(p \\land q)\\lor (p \\land \\lnot q)(p∧q)∨(p∧¬q) T ¬(p∧q)∨r\\lnot(p \\land q) \\lor r¬(p∧q)∨r F how to obtain Normal Forms Use logical Equivalences. Examples $\\lnot ((p \\lor q) \\land \\lnot r) \\Leftrightarrow \\lnot (p \\lor \\lnot q) \\lor r \\Leftrightarrow (\\lnot p \\land q) \\lor r \\Leftrightarrow (\\lnot p \\lor r) \\land (q\\lor r)$ Full Disjunctive Normal Forms **【Definition】**A minterm is a conjunction of literals in which each variable is represented exactly once. **【Definition】**If a formula is expressed as a disjunction of minterms, it is said to be in full disjunctive normal form. Example : $(p \\land q \\land r) \\lor (p \\land q \\land \\lnot r) \\lor (\\lnot p \\land q \\land r) \\lor (\\lnot p \\land \\lnot q \\land \\lnot r)$ Prenex Normal Form **【Definition】**A statement is in prenex normal form iff it is of the form Q1x1...QnxnBQ_1x_1...Q_nx_n BQ1​x1​...Qn​xn​B,where Qi(i=1,2...n)Q_i (i=1,2...n)Qi​(i=1,2...n) is $\\land $ or ∨\\lor∨ and the predicate B is quantifier free. Examples: ∧xP(x)∨∧xQ(x)\\land xP(x) \\lor \\land xQ(x)∧xP(x)∨∧xQ(x) F ∧x∧y¬(P(x)→Q(y))\\land x \\land y \\lnot (P(x) \\rightarrow Q(y))∧x∧y¬(P(x)→Q(y)) T Transforming to Prenex NOrmal Form 1.6 Rules of Inference Valid Arguments 【Definition】 An argument in propositional logic is a sequence of propositions. All but the final proposition in the argument are called premises and the final proposition is called the conclusion. An argument is valid if the truth of all its premises implies that the conclusion is true. An argument form in propositional logic is a sequence of compound propositions involving propositional variables. An argument form is valid if no matter which particular propositions are substituted for the propositional variables in its premises, the conclusion is true if the premises are all true. Examples: “If you have a current password, then you can log onto the network”（premises） “You have a current password”（premises） “You can log onto the network”（conlusion） ((p→q)∧p)→q((p \\rightarrow q)\\land p)\\rightarrow q((p→q)∧p)→q Rules of Inference","categories":[{"name":"note","slug":"note","permalink":"http://amb1t10n.github.io/categories/note/"}],"tags":[{"name":"study","slug":"study","permalink":"http://amb1t10n.github.io/tags/study/"}]},{"title":"C语言指针","slug":"my-annual-summary","date":"2020-01-14T01:58:48.000Z","updated":"2020-01-23T08:33:14.592Z","comments":true,"path":"2020/01/14/my-annual-summary/","link":"","permalink":"http://amb1t10n.github.io/2020/01/14/my-annual-summary/","excerpt":"","text":"对于很多人来说，指针这块东西确实让人难懂 但是他的名字很形象地表现他的性质 他就是一个指向某块数据的类型，就类似于一种快捷方式 你可以用指针迅速访问你要代表的那个变量 利用指针对原来那个变量做出各种操作 指针类型 指针也是一种数据类型，他的值是一串16进制的数，表示的是地址，也就是在内存中，所代表的数据的位置， 定义指针的时候也是那几种 比如char*、int*、double*等等，也可以是指向指针的指针，比如 int** ，指向指针的指针的指针的…套娃。但是他比常用的数据类型还多了一种void*也就是可以指向任何类型的指针 但是这并不代表ElementType*是一种类型，*只是一种标记，在哪个变量前面就代表哪个就是指针，并没有int *这种类型。 指针的定义 指针定义的时候，是通过*来区别是指针还是普通的变量。 使用时通过 * 来访问所代表的变量的值 int *p,q; 在这句中，只有p是指针，而q是普通的int型的变量 int中存储的变量是整数，double中是双精度浮点数，那么指针呢？ 指针中存储的是地址，所以赋值的时候，是用&amp;取址来赋值 #include &lt;stdio.h&gt; int main(){ int n=5; int *a=&amp;n; int *p=0; int *q=2; printf(&quot;%x %p\\n&quot;,a,&amp;n); printf(&quot;%d %d&quot;,n,*a); return 0; } 上图即为此段代码的运行结果 我们不难发现，a的值是和n的地址是一样的，并且n和*a的值也相同。 所以在定义的时候可以将一个指针的值赋值给另一个 就比如int *new=a,在此时，a中的地址赋值给new, new就也指向了n 在这块代码中，定义了一个指针 a ，并且对a进行赋值，也就是n的地址，&amp;在这则是取址符号，即取出n的地址，使得a指向n 在下一行的printf中，由于*在a前，把a指向的变量取出，所以两个值是相同的 但是int *p=0;与int *q=2这两句，将整数赋给指针，那么在这的整数，就是一句无报错一句有报错，这是怎样一回事呢？ 在这两句中，0 2都被当作是地址，但0可以理解为一种特殊的地址，对指针进行初始化的时候常常用到0或者是NULL，此二者是相同的，在指针定义后没有被初始化时，我们不知道它指向何处，所以称它为“野指针”，所以赋值0是不会有“王宁”的，但是2的地址是一个不可写的位置所以在这句中会有warning 指针的应用 众所周知（学了C的人都知道），C的函数中，return只能返回一个值，而想要在函数中返回两个值甚至多个值，就需要通过函数传入所要改变的值的地址，在函数内部进行操作，从而改变函数外这个变量的值，进而达到返回多个值的目的 #include &lt;stdio.h&gt; int find(int a,int b,int *min); int main(){ int a=5,b=6; int max,min; max=find(a,b,&amp;min); printf(&quot;%d %d&quot;,max,min); return 0; } int find(int a,int b,int *min){ return a&gt;b?(*min=b,a):(*min=a,b); } 我们通过这样的一个函数来找出两个数中的最大值和最小值，当然不可否认的是，这样做确实比较蠢，但是个人觉得这是一个很好的例子，来说明通过指针来返回多个数据。在后期甚至会遇到需要将一个链表拆分成两个链表，并且在main函数中输出，此时则需要函数返回一个，再对原来的链表操作从而达到返回两个链表的目的 还有我们想要通过函数去交换两个数的值，比如这样 void swap(int a,int b){ int temp=a; a=b; b=temp; } 指针与数组 数组是在内存中一连串的数据空间，通过[]来访问对应位置上的元素，指针则是指向空间中某个位置。 在c89的时候，不能用未知量来定义数组，int a[n]这种行为是非法的，而在那个时候就是用 int *a=malloc(sizeof(int)*n); 可以使用这样的方式来申请一块连续的内存空间，从而达到存储的目的。 在函数中，传入数组时，数组会退化成指针，而数组的头就是a[0]的地址，即a==&amp;a[0]或者*a==a[0] 此时的a是int的一维数组，当a是int的二维数组时，a就变成了一个int **a，也就是指向指针的指针。 而字符串数组比较特殊。","categories":[],"tags":[{"name":"study","slug":"study","permalink":"http://amb1t10n.github.io/tags/study/"}]}]}