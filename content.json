{"meta":{"title":"amb1t10n's blog","subtitle":"","description":"","author":"amb1t10n","url":"http://amb1t10n.github.io","root":"/"},"pages":[{"title":"关于自己","date":"2020-01-15T03:08:28.000Z","updated":"2020-01-15T03:47:03.582Z","comments":true,"path":"about/index.html","permalink":"http://amb1t10n.github.io/about/index.html","excerpt":"","text":"谈谈写博客的想法作为一个以后要靠技术吃饭的清(you)纯(ni)少(da)年(shu)有一个自己的blog是有必要的而且在成长的过程中对身边的一些事情有一些看法自己也不想去发到QQ空间这种地方让公开评论就想着发到blog中算是发泄一下自己的小情绪吧"},{"title":"Categories","date":"2020-03-01T11:16:25.000Z","updated":"2020-03-01T11:17:02.398Z","comments":true,"path":"category/index.html","permalink":"http://amb1t10n.github.io/category/index.html","excerpt":"","text":""},{"title":"Tags","date":"2020-03-01T11:16:12.000Z","updated":"2020-03-01T11:17:05.592Z","comments":true,"path":"tag/index.html","permalink":"http://amb1t10n.github.io/tag/index.html","excerpt":"","text":""}],"posts":[{"title":"buffer overflow","slug":"buffer-overflow","date":"2020-03-31T12:06:33.000Z","updated":"2020-03-31T12:11:24.038Z","comments":true,"path":"2020/03/31/buffer-overflow/","link":"","permalink":"http://amb1t10n.github.io/2020/03/31/buffer-overflow/","excerpt":"","text":"Buffer overflow实验报告姓名:张喜瑜 学号：3190104667 班级：图灵1901 【实验环境】 Ubuntu 18.04 64bit LTS版本 从学在浙大下载得到32位可执行文件 hw 执行sudo sysctl -w kernel.randomize_va_space=0关闭ASLR 【实验目的】 了解buffer overflow原理 利用buffer overflow改变分支，进行输出 【实验步骤】一、获得变量地址 打开终端，进入hw所在文件夹 在终端输入，objdump -d hw &gt; hw.asm，生成Linux 32位汇编代码 打开hw.asm，并寻找main函数中定义变量部分 得到isRoot地址为-0xc(%ebp) 二、使用gdb获得ebp及buffer地址 在终端中键入gdb hw 在main函数处设置断点，输入b main 运行hw ,输入r 查看栈基地址,输入p /x \\$ebp，得到$ebp地址为0xffffce98 输入c，继续。得到buffer地址，为0xffffce80 三、计算要overwrite的变量和buffer之间的偏移量 isRoot地址为-0xc(%ebp)，即0xffffce98-0xc==0x8c 与buffer之间的偏移地址为：0x8c-0x80+4=0x10 四、在isRoot处写入0x41424344 Inter80$\\times$86芯片为小端格式，即数据的高字节保存在内存的高地址中，即16进制的41 42 43 44在内存中从高到低，由于写入时为低位到高位，故依次输入44 43 42 41。 由于直接输入44 43 42 41会导致读取8个字节，可输入0x44 ASCII码对应的字符，即D。 输入任意12个字符，再输入DCBA 得到输出：pwded! 【实验结果】 如何获得isRoot地址 由于对汇编语言不太熟悉，在获得ebq地址时，认为ebq地址为isRoot地址，获得偏移地址为0x18-4，输出错误。仔细阅读汇编语言后，发现movl $0x0,-0xc(%ebp)这条指令，猜测-0xc(%ebp)为isRoot地址。 后将源码改为 123456789101112#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void main() &#123; short int isRoot = 0; char buffer[12]; printf(\"the address of buffer is %p \\n\", buffer); gets(buffer); if (isRoot ==0x41424344) &#123; printf(\"pwned! \\n\"); &#125; return;&#125; 再反汇编得到 可以看到 12movl $0x0,-0xc(%ebp) ;变为；movw $0x0,-0a(%ebp) 由此确认-0xc(%ebp)为isRoot地址。 如何了解0x41424344在内存中储存位置 通过网上搜索相关内容，了解到数据的高字节保存在内存的高地址中。 并且通过下列代码证实 123456789#include &lt;stdio.h&gt;int main()&#123; int a=0x41424344; char *p=&amp;a; for (int i=0;i&lt;4;i++)&#123; printf(\"%x \",p[i]); &#125;&#125;//得到输出为44 43 42 41 输入16进制44 43 42 41 实验时通过输入DCBA的方式进行 通过|管道链接,实现输入 12345#include &lt;stdio.h&gt;int main()&#123; printf(\"\\x44\\x43\\x42\\x41\"); return 0;&#125;","categories":[],"tags":[]},{"title":"wireshark-抓包实验报告","slug":"wireshark-抓包实验报告","date":"2020-03-28T11:47:16.688Z","updated":"2020-03-28T12:05:38.594Z","comments":true,"path":"2020/03/28/wireshark-抓包实验报告/","link":"","permalink":"http://amb1t10n.github.io/2020/03/28/wireshark-%E6%8A%93%E5%8C%85%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/","excerpt":"","text":"Wireshark抓包实验报告 专业班级：图灵1901 &nbsp; 学号 ：3190104667 &nbsp; 姓名： 张喜瑜 【实验目的】 了解TCP/IP协议下五层协议及其作用。 利用wireshark进行抓包，分析TCP与UDP包，并理解packet headers 是如何被封装的。 了解TCP的三次握手的过程。 【实验步骤】 打开浏览器与Wireshark 在捕获选项中双击选择“以太网”，并开始抓包 在浏览器中打开网站，如 https://www.3dmgame.com/ 停止抓包并分析抓包结果 在过滤器中选择http过滤，并查看过滤结果。选择GET / HTTP/1.1 中记录，右键-&gt;追踪流-&gt;tcp流，查看前三个TCP包中Transmission Control Protocol内容，分析三次握手过程。) 再在过滤器中键入udp,双击并查看User Datagram Protcol 中内容。 【实验结果】 TCP/IP协议下五层协议是什么，它们有什么作用？&emsp;TCP/IP协议下，从上到下一共有五层：应用层、运输层、网络层、链路层、物理层应用层：应用层是网络应用程序及它们的应用层协议存留的地方，如HTTP（提供Web文档的请求与传送），SMTP（提供电子邮件报文的传输）和FTP(提供两个端系统之间的文件传送)，由DNS完成域名到比特网络地址的转换。 运输层：运输层在应用程序端点之间传送应用层报文。在因特网中，存在两个传输协议，TCP和UDP，利用其中的任一个都能运输应用层报文。TCP向它的应用程序提供了面向连接的服务。UDP协议向它的应用程序提供无连接服务。网络层:网络层负责将数据报的网络层分组从一台主机移动到另一台主机。链路层：通过一系列路由器在源和目的地之间发送分组，实现数据的传递。物理层：将链路层要移动的帧中的比特一个一个从一个节点移动到下一个节点。这层协议与链路层相关，与实际传输媒体相关，如铜线，光纤，无线电。2. 举例说明TCP的三次握手是如何实现的？我们从下图中可以看到，经过三次TCP包的传输之后，得到了HTTP包。并且我们知道了，客户端的ip address:192.168.1.117,服务器ip address:122.195.200.82从客户端发送给服务器一个TCP数据包，标志位位[SYN]，Seq=0，表示客户端请求连接。此时服务器确认服务器的接收能力与客户端发送能力正常。下图为TCP第二次握手的数据包，由服务器发送给客户端，标志位为[SYN，ACK],此时，返回的数据包中，Seq=0,Ack=客户端发送的数据包中Seq+1，即Ack=0+1=1。此时，客户端确认客户端的接收，发送能力与服务器的接收，发送能力正常。再第三次TCP握手中，由客户端发送给服务器发送确认包，将Ack设置为对方发来的Seq+1，即0+1=1。此时，服务器确认到双方的发送与接收能力正常。经过三次握手之后，客户端与服务器均确认双方接收与发送数据包的能力正常，可以建立连接。3. 用一个TCP包与UDP包举例说明packet headers是怎样组成的如图所示为TCP packet header及12位标志位内容)这是第一次握手时，客户端发送到服务器的TCP数据报，该packet表示请求建立连接，故无确认序号，A/Acknowledgment为0，S/Syn为1.下图为UDP packet header中内容再过滤获得UDP数据报时，过滤结果并不只有UDP，还有OICQ、SSDP、MDNS、DNS等等，这些都是基于UDP，故得到不知UDP协议。对比TCP以及UDP packet header内容，可以发现二者所含内容有较大区别。在搜索相关资料后了解到： TCP与UDP分别给予连接与无连接 TCP能够保证数据正确性，UDP可能丢包 TCP保证数据顺序，UDP不保证 举例说明怎样利用TCP三次握手做DDoS攻击由于TCP在发送数据段的同时启动一个重传，若在重传超时之前收到Acknowledgment就关闭重传，若没有收到，则重传该数据段。而且TCP保证数据顺序，则可以伪造源IP地址，向服务器发送大量的Syn报文，当服务器回复Syn+Ack报文时，客户端不予回应，使Syn+Ack报文被重传，从而占据半开连接队列，阻止其他用户访问。 重放攻击的原理是怎样的，提供一种可能的防御手段，分析优缺点。重放攻击的基本原理就是把以前窃听到的数据原封不动地重新发送给接收方，从而达到欺骗系统的目的。可以采用一次性密钥，每次数据传输的加密密钥均需更改，即使将捕获的数据报重新发送，也达不到目的。优点：密码只能使用一次，为动态产生，所以不可预测，也只有一次使用有效性，可以有效防御重放攻击。缺点：若客户端和服务器双方时间不同步或者由于其他网络因素，导致客户端在密钥有效时间内无法输入，导致合法用户无法登录。","categories":[],"tags":[]},{"title":"汇编笔记","slug":"汇编笔记","date":"2020-03-23T04:59:54.555Z","updated":"2020-03-25T15:29:09.249Z","comments":true,"path":"2020/03/23/汇编笔记/","link":"","permalink":"http://amb1t10n.github.io/2020/03/23/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0/","excerpt":"","text":"汇编笔记一、汇编代码初见及其编译及调试###1、sum.asm .386 .model flat, stdcall option casemap :none include include\\windows.inc include include\\kernel32.inc include include\\user32.inc includelib lib\\kernel32.lib includelib lib\\user32.lib .data result db 100 dup(0); dup:duplicate重复 ;char result[100]={0}; format db &quot;%d&quot;,0; db:define byte字节类型 ; char format[3]=&quot;%d&quot;; prompt db &quot;The result&quot;,0 .code main: ; 标号 mov eax, 0; ；eax:extended ax，eax是32位寄存器低16位为ax，高16位没名字 mov ebx, 1； 这两句可以相当于是定义全局变量，eax，ebx为寄存器 again: ;函数 add eax, ebx; eax=0+1+2+3 add ebx, 1 ; ebx=4 cmp ebx, 100; cmp:compare jbe again ; jbe:jump if below or equal invoke wsprintf,offset result,offset format,eax invoke MessageBox,0,offset result,offset prompt,0 ret end main; 指定程序的起始执行点 ; end后面的标号决定了程序刚开始 ; 运行时的eip的值。include include\\***.inc类似与C中引入库函数，在实现输入输出功能.data为汇编代码的数据段，.code为代码段，变量均在数据段定义。在代码段中，main:为函数开头，类似于C中main():，但是存在较大差异，main:只是一种标号，可以将其改名为任何形式，但是其后必须存在:invoke相当于是宏定义来调用函数，从后往前将参数输入进函数wsprintf为函数，后面三个为所需参数，意为：将eax的值以format的形式输入进数组result中，即 wsprintf(result,format,eax)；相当于C中这种形式 转化为汇编语言 push eax push offset format push offset result call wsprintf add esp 0Ch 最后一步清除堆栈，0Ch为12，即上面三条push同理， invoke MessageBox,0,offset result,offset prompt,0输入MessageBox所需的参数，最后的0 ，为弹出窗口的格式，即最简单的格式:只有一个“OK”按钮，prompt为弹窗的名称，result需要显示的字符串，最前面的数字为父弹窗的所属关系，0为不依靠任何窗口，即独立。offset为取址，即&amp; 2、编译与调试对与32位windows系统，需要先打开qeditor，后打开所要编译文件，project-&gt;build all，弹出生成.exe文件即可，可在相应文件夹打开或者project-&gt;run program打开生成程序。32位的windows进行调试，需要将生成的.exe文件，拖入Ollydug中，在OD中打开后，F2设置断点，F8单步进行，F7进入函数，双击汇编代码或者机器语言可将其修改，但是本次修改只能在本次进行中保存。 具体指令add (sub与add相同）add 加法操作符，可进行： add 寄存器，寄存器如 add ax,bx add 寄存器，变量 如 add ax,ds:[1000h] add 寄存器，常数 如 add ax,1 add 变量，寄存器 如：add ds:[1000h],ax add 变量，常数 如：add word ptr ds:[1000h] ,2ptr 相当于强制类型转换，类似的有 byte ptr``dword ptr word ptradd 变量，变量语法错误：因为CPU不支持同时操作两个内存变量想要实现变量和变量的加法，可以使用如下方式 mov ax,x add y,ax其效果等同于y+=x;同时 mov ax ,bh语法错误，因为左右不等宽 逻辑运算 and 和 add ax,bx 等同 ax=ax&amp;bx or 或 or ax,bx 等同 ax=ax|b xor 异或 xor ax,bx 等同 ax=ax^bx not 非 not ax 等同 ax=~ax shl 左移 shl ax,bx 等同 ax=ax&lt;&lt;bx shr 右移 shr ax,bx 等同 ax=ax&gt;&gt;bx rol循环左移 rol ax,1 等同 ax =_rol(ax,1) ror循环右移 ror等同 ax =_ror(ax,1) mov ah,101110110B rol ah,1;AH=0110 1101=6Dh mov ah,10110111B ror ah,1;AH=1101 1011=0DBh在编程时引用一个16进制常数时，若恰好是以字母开头，则不仅要加后缀h,还需要加前缀0 位运算作用 可使某些位变0如： 1111 0000 用 0000 1111 and 变为 0000 0000 用or使某些位变1 用xor反转某些位在数据段之前，加入.386,data segment，code segment后加入use 16可使用32位寄存器。","categories":[],"tags":[]},{"title":"Note of Discrete Mathematics and Its Applications","slug":"page","date":"2020-03-01T08:00:48.000Z","updated":"2020-03-02T07:58:48.914Z","comments":true,"path":"2020/03/01/page/","link":"","permalink":"http://amb1t10n.github.io/2020/03/01/page/","excerpt":"","text":"Chapter 11.1 propositional logical命题逻辑Proposition【Definition】：A proposition is a declarative sentence that is either true or false, but not both.例如： 1+1=2 华盛顿特区是美利坚合众国的首都are True propositions 2+3=1is false proposition Notice：The assert The statement is false proposition is not a proposition.Because no matter what the truth value is,there is a contradition. 1.2 Logical operators1 Negation(NOT)$\\lnot$【Definition】Let $p$ be a proposition.The negation of p,$\\lnot p$ is the proposition”It is not the case that $p$”Example: $p$:Michael’s PC runs Linux$\\lnot p$:Michael’s PC does not run Linux 2. Conjunction(AND)$\\bigwedge$（和取）【Definition】:Let $p$ and q be propositions. The conjunction of $p$ and $q$, denoted by $p \\bigwedge q$, is the proposition“$p$ and $q$.” The conjunction $p \\bigwedge q$ is true when both $p$ and $q$ are true and is false otherwise.Example :I have an apple and a pencil. 3. Disjunction(OR)$\\bigvee$（析取）【Definition】Let $p$ and $q$ be propositions. The disjunction of $p$ and $q$, denoted by $p \\bigvee q$, is the proposition“$p$ or $q$.” The disjunction $p \\bigvee q$ is false when both $p$ and $q$ are false and is true otherwise. 4. Exclusive or(XOR)$\\bigoplus$（异或）【Definition】:$p \\bigoplus q$ is $p$ or $q$ but not both. 5. Conditional(IF–THEN)$\\rightarrow$【Definition】The conditional statement $p \\rightarrow q$ is the proposition “if $p$, then $q$.”$p \\rightarrow q$ can be exprssed as: 6. Biconditional(IF AND ONLY IF)$\\longleftrightarrow$【Definition】:Let $p$ and $q$ be propositions. The biconditional statement $p \\leftrightarrow q$, is the proposition “$p$ if and only if (iff) $q$.”$p \\longleftrightarrow q$ can be exprssed as: 7.Precedence of Logical Operators operator precedence $\\lnot$ 1 $\\bigwedge$ 2 $\\bigvee$ 3 $\\rightarrow$ 4 $\\leftrightarrow$ 5 8.Truth table $x$ $y$ $\\lnot x$ $x \\bigwedge y$ $x \\bigvee y$ $x \\bigoplus y$ $x \\leftarrow y$ $x \\leftrightarrow y$ T T F T T F T T F T T F T T T F T F F F T T F T F F T F F F T T Translating English sentencesExample:Translate You can access the Internet from campus only if you are a computer science major or you are not a freshmanSolution:Let $a$:you can access the Internet from campus$c$:you are a computer science major$f$:you are a freshmanThis sentence can be represented as $a \\rightarrow (c \\bigvee \\lnot f)$ 1.3 Logical Equivalences【Definition】:The compound propositions p and q are called logically equivalent if $p \\leftrightarrow$ is a tautology.Notation:$p \\equiv q$ or $p \\Leftrightarrow q$NOR:The proposition p NOR q is true when both p and q are false, and it is false otherwise. The operator $\\downarrow$ is called Peirce arrow. 1.4 Predicates and Quantifiers1.5 Nested quantifiersnested quantifiersA statement can have multiple variables【Definition】:Two quantifiers are nested if one is within the scope of the other.Example:Let C(x,y)denote “x has taken course y”where the domain of x and y consist of all ZJU students and all CS courses.$\\forall x \\exists y C(x,y)$ :Every student at ZJU has taken some CS course.$\\exists x \\forall y C(x,y)$ :Some student at ZJU has taken all CS courses.Translate: Translate the statement $\\forall x(C(x) \\bigvee \\exists y(C(x) \\bigwedge F(x,y)))$into English,where $C(x)$ is “x has a computer,”$F(x)$is “x and y are friends”and the domain for both x and y consists of all students at ZJU.Solution::Every student at ZJU has a computer or has a friend who has a computer. Express the statement “Everyone has exactly one best friend” as a logical expression with a domain consisting of all people.Solution:”For every person x,x has exactly one best friend”$\\Rightarrow$”There is a person y who is the best friend of x,and furthermore,that for every person z,if z is not y,then z is not the best friend of x.”Let $B(x,y)$ be the statement “y is the best friend of x” $\\forall x \\exists y \\forall z (B(x,y) \\bigwedge ((z \\neq y)\\rightarrow \\lnot B(x,z)))$ The order of quantifiersthe order of nested quantifiers matters if quantifiers are different types: $\\forall x \\forall y \\equiv \\forall y \\forall x$ $\\exists x \\forall yP(x,y) \\neq \\forall y \\exists x P(x,y)$ Negating Nested quantifersNegating nested quantifiers by successively applying the rules for negating statements involving a single quantifier.Example: Express the negation of the statement $\\forall x \\exists y (xy=1)$ so that no negation precedes a quantifiers.Solution:$\\lnot \\forall x \\exists y (xy=1) \\\\equiv \\exists x(\\lnot \\exists (xy=1)) \\\\equiv \\exists x \\forall y (\\lnot (xy=1)) \\\\equiv \\exists x \\forall y (xy \\neq 1)$ Propositional Normal FormsLiteral:$p$ $or$ $\\lnot p$【Definition】:Disjunctions(conjunctions) with literals as disjuncts are calles is djunctions(conjunctions) clauses.Disjunctive and conjunctive clauses are simply called clauses.Examples: $q \\lor r$ &emsp; Disjunctive clause $\\lnot q \\land p$ &emsp; Conjunctive clause $p \\land q \\lor r$ &emsp; Not a clauseConjunctive Normal Form(CNF) 【Definition】 A conjunction with disjunctive clauses as its conjuncts is said to be in conjunctive normal form.Examples: $p \\land (q \\lor r)$ &emsp; T $\\lnot q \\land p$ &emsp; T $p \\land ((p \\land q) \\lor r$&emsp;F Disjunctive Normal Form(DNF) 【Definition】A disjunction with conjunctive clauses as its disjuncts is said to be in disjunctive normal form.Examples: $(p \\land q)\\lor (p \\land \\lnot q)$ &emsp; T $\\lnot(p \\land q) \\lor r$ &emsp; F how to obtain Normal FormsUse logical Equivalences. Examples $\\lnot ((p \\lor q) \\land \\lnot r) \\Leftrightarrow \\lnot (p \\lor \\lnot q) \\lor r \\Leftrightarrow (\\lnot p \\land q) \\lor r \\Leftrightarrow (\\lnot p \\lor r) \\land (q\\lor r)$ Full Disjunctive Normal Forms【Definition】A minterm is a conjunction of literals in which each variable is represented exactly once.【Definition】If a formula is expressed as a disjunction of minterms, it is said to be in full disjunctive normal form.Example : $(p \\land q \\land r) \\lor (p \\land q \\land \\lnot r) \\lor (\\lnot p \\land q \\land r) \\lor (\\lnot p \\land \\lnot q \\land \\lnot r)$ Prenex Normal Form【Definition】A statement is in prenex normal form iff it is of the form $Q_1x_1…Q_nx_n B$,where $Q_i (i=1,2…n)$ is $\\land $ or $\\lor$ and the predicate B is quantifier free.Examples: $\\land xP(x) \\lor \\land xQ(x)$ F $\\land x \\land y \\lnot (P(x) \\rightarrow Q(y))$ T Transforming to Prenex NOrmal Form1.6 Rules of InferenceValid Arguments 【Definition】 An argument in propositional logic is a sequence of propositions.All but the final proposition in the argument are called premises and the final proposition is called the conclusion.An argument is valid if the truth of all its premises implies that the conclusion is true.An argument form in propositional logic is a sequence of compound propositions involving propositional variables.An argument form is valid if no matter which particular propositions are substituted for the propositional variables in its premises, the conclusion is true if the premises are all true.Examples: “If you have a current password, then you can log onto the network”（premises） “You have a current password”（premises） “You can log onto the network”（conlusion） $((p \\rightarrow q)\\land p)\\rightarrow q$ Rules of Inference","categories":[{"name":"note","slug":"note","permalink":"http://amb1t10n.github.io/categories/note/"}],"tags":[{"name":"study","slug":"study","permalink":"http://amb1t10n.github.io/tags/study/"}]},{"title":"C语言指针","slug":"my-annual-summary","date":"2020-01-14T01:58:48.000Z","updated":"2020-01-23T08:33:14.592Z","comments":true,"path":"2020/01/14/my-annual-summary/","link":"","permalink":"http://amb1t10n.github.io/2020/01/14/my-annual-summary/","excerpt":"","text":"对于很多人来说，指针这块东西确实让人难懂但是他的名字很形象地表现他的性质他就是一个指向某块数据的类型，就类似于一种快捷方式你可以用指针迅速访问你要代表的那个变量利用指针对原来那个变量做出各种操作 指针类型指针也是一种数据类型，他的值是一串16进制的数，表示的是地址，也就是在内存中，所代表的数据的位置，定义指针的时候也是那几种比如char*、int*、double*等等，也可以是指向指针的指针，比如 int** ，指向指针的指针的指针的……套娃。但是他比常用的数据类型还多了一种void*也就是可以指向任何类型的指针但是这并不代表ElementType*是一种类型，*只是一种标记，在哪个变量前面就代表哪个就是指针，并没有int *这种类型。 指针的定义指针定义的时候，是通过*来区别是指针还是普通的变量。使用时通过 * 来访问所代表的变量的值 int *p,q;在这句中，只有p是指针，而q是普通的int型的变量int中存储的变量是整数，double中是双精度浮点数，那么指针呢？指针中存储的是地址，所以赋值的时候，是用&amp;取址来赋值 #include &lt;stdio.h&gt; int main(){ int n=5; int *a=&amp;n; int *p=0; int *q=2; printf(&quot;%x %p\\n&quot;,a,&amp;n); printf(&quot;%d %d&quot;,n,*a); return 0; }上图即为此段代码的运行结果我们不难发现，a的值是和n的地址是一样的，并且n和*a的值也相同。所以在定义的时候可以将一个指针的值赋值给另一个就比如int *new=a,在此时，a中的地址赋值给new, new就也指向了n在这块代码中，定义了一个指针 a ，并且对a进行赋值，也就是n的地址，&amp;在这则是取址符号，即取出n的地址，使得a指向n在下一行的printf中，由于*在a前，把a指向的变量取出，所以两个值是相同的但是int *p=0;与int *q=2这两句，将整数赋给指针，那么在这的整数，就是一句无报错一句有报错，这是怎样一回事呢？在这两句中，0 2都被当作是地址，但0可以理解为一种特殊的地址，对指针进行初始化的时候常常用到0或者是NULL，此二者是相同的，在指针定义后没有被初始化时，我们不知道它指向何处，所以称它为“野指针”，所以赋值0是不会有“王宁”的，但是2的地址是一个不可写的位置所以在这句中会有warning 指针的应用众所周知（学了C的人都知道），C的函数中，return只能返回一个值，而想要在函数中返回两个值甚至多个值，就需要通过函数传入所要改变的值的地址，在函数内部进行操作，从而改变函数外这个变量的值，进而达到返回多个值的目的 #include &lt;stdio.h&gt; int find(int a,int b,int *min); int main(){ int a=5,b=6; int max,min; max=find(a,b,&amp;min); printf(&quot;%d %d&quot;,max,min); return 0; } int find(int a,int b,int *min){ return a&gt;b?(*min=b,a):(*min=a,b); }我们通过这样的一个函数来找出两个数中的最大值和最小值，当然不可否认的是，这样做确实比较蠢，但是个人觉得这是一个很好的例子，来说明通过指针来返回多个数据。在后期甚至会遇到需要将一个链表拆分成两个链表，并且在main函数中输出，此时则需要函数返回一个，再对原来的链表操作从而达到返回两个链表的目的还有我们想要通过函数去交换两个数的值，比如这样 void swap(int a,int b){ int temp=a; a=b; b=temp; }指针与数组数组是在内存中一连串的数据空间，通过[]来访问对应位置上的元素，指针则是指向空间中某个位置。在c89的时候，不能用未知量来定义数组，int a[n]这种行为是非法的，而在那个时候就是用 int *a=malloc(sizeof(int)*n);可以使用这样的方式来申请一块连续的内存空间，从而达到存储的目的。在函数中，传入数组时，数组会退化成指针，而数组的头就是a[0]的地址，即a==&amp;a[0]或者*a==a[0]此时的a是int的一维数组，当a是int的二维数组时，a就变成了一个int **a，也就是指向指针的指针。而字符串数组比较特殊。","categories":[],"tags":[{"name":"study","slug":"study","permalink":"http://amb1t10n.github.io/tags/study/"}]}]}